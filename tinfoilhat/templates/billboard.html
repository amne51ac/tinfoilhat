<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tinfoil Hat Competition - Billboard</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/billboard.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap');
        
        body {
            background-color: #0a0a0a;
            color: #33ff33;
            font-family: 'VT323', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
        }
        
        .nav-links {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
            text-align: right;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
        }
        
        .nav-link {
            display: inline-block;
            padding: 4px 8px;
            color: #33ff33;
            text-decoration: none;
            font-weight: bold;
            transition: color 0.3s;
        }
        
        .nav-link:hover {
            color: #ffffff;
            text-decoration: underline;
        }
        
        /* CRT screen effect with scanlines */
        body::before {
            content: "";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0.1;
        }
        
        /* CRT flicker animation */
        body::after {
            content: "";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 1001;
            pointer-events: none;
            animation: flicker 0.15s infinite alternate;
        }
        
        @keyframes flicker {
            0% { opacity: 0.025; }
            100% { opacity: 0.05; }
        }
        
        .billboard-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        
        .billboard-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #33ff33;
            padding-bottom: 10px;
            position: relative;
        }
        
        .billboard-header::after {
            content: "";
            position: absolute;
            bottom: -2px;
            left: 30%;
            right: 30%;
            height: 2px;
            background: #33ff33;
            box-shadow: 0 0 5px #33ff33;
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from { opacity: 0.7; box-shadow: 0 0 3px #33ff33; }
            to { opacity: 1; box-shadow: 0 0 8px #33ff33; }
        }
        
        .billboard-header h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 2.2em;
            margin: 0;
            color: #33ff33;
            letter-spacing: 2px;
            text-shadow: 0 0 3px #33ff33;
            text-transform: uppercase;
        }
        
        .billboard-content {
            display: flex;
            flex: 1;
            gap: 20px;
        }
        
        .leaderboards-container {
            display: flex;
            flex: 1;
            gap: 20px;
        }
        
        .leaderboard {
            flex: 1;
            background-color: #111;
            border: 2px solid #33ff33;
            border-radius: 5px;
            padding: 15px;
            box-shadow: inset 0 0 10px rgba(51, 255, 51, 0.3);
            position: relative;
            overflow: hidden;
            height: calc(100vh - 200px); /* Fixed height with space for header */
            display: flex;
            flex-direction: column;
        }
        
        .leaderboard::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #33ff33;
            box-shadow: 0 0 3px #33ff33;
        }
        
        .leaderboard h2 {
            text-align: center;
            margin-top: 0;
            color: #33ff33;
            border-bottom: 1px solid #33ff33;
            padding-bottom: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.4em;
            text-shadow: 0 0 2px #33ff33;
        }
        
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            overflow-y: auto;
            flex: 1;
        }
        
        .leaderboard-table tbody {
            display: block;
            overflow-y: auto;
            max-height: calc(100% - 50px); /* Account for header */
        }
        
        .leaderboard-table thead,
        .leaderboard-table tbody tr {
            display: table;
            width: 100%;
            table-layout: fixed;
        }
        
        .leaderboard-table th, .leaderboard-table td {
            padding: 10px;
            text-align: left;
            font-size: 1.5em;
            border-bottom: 1px solid rgba(51, 255, 51, 0.3);
        }
        
        .leaderboard-table th {
            border-bottom: 1px solid #33ff33;
            color: #fff;
            text-shadow: 0 0 2px #33ff33;
            font-size: 1.3em;
        }
        
        .leaderboard-table tbody tr:hover {
            background-color: rgba(51, 255, 51, 0.1);
        }
        
        .rank {
            font-weight: bold;
            width: 40px;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 1em;
        }
        
        .attenuation {
            text-align: center;
            font-weight: bold;
            font-family: monospace;
            font-size: 1.3em;
        }
        
        .first-place {
            background-color: rgba(255, 215, 0, 0.2) !important;
            position: relative;
        }
        
        .first-place td {
            color: #ffdd00;
            text-shadow: 0 0 2px rgba(255, 215, 0, 0.7);
        }
        
        .second-place {
            background-color: rgba(192, 192, 192, 0.2) !important;
        }
        
        .second-place td {
            color: #cccccc;
        }
        
        .third-place {
            background-color: rgba(205, 127, 50, 0.2) !important;
        }
        
        .third-place td {
            color: #cc9966;
        }
        
        .negative-attenuation {
            color: #ff5555;
            text-shadow: 0 0 2px rgba(255, 0, 0, 0.7);
        }
        
        .testing-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #recent-test {
            flex: 1;
            background-color: #111;
            border: 2px solid #33ff33;
            border-radius: 5px;
            padding: 20px;
            box-shadow: inset 0 0 10px rgba(51, 255, 51, 0.3);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 200px); /* Fixed height with space for header */
        }
        
        #recent-test::before {
            content: "LATEST TEST";
            position: absolute;
            top: 0;
            left: 0;
            background: #33ff33;
            color: #000;
            font-size: 0.8em;
            padding: 2px 10px;
            font-family: 'Press Start 2P', cursive;
            font-weight: bold;
        }
        
        .test-info {
            text-align: center;
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(51, 255, 51, 0.3);
        }

        #recent-test .contestant-name {
            font-size: 2.2em;
            font-weight: bold;
            margin-bottom: 5px;
            margin-top: 15px;
            text-shadow: 0 0 2px #33ff33;
        }
        
        #recent-test .hat-type {
            font-size: 1.8em;
            color: #bbffbb;
            margin-bottom: 10px;
        }
        
        #recent-test .attenuation {
            font-size: 2.8em;
            font-weight: bold;
            margin-bottom: 5px;
            font-family: 'VT323', monospace;
            text-shadow: 0 0 5px #33ff33;
            text-align: center; /* Center the text */
        }
        
        #recent-test .test-date {
            font-size: 1.2em;
            color: #99ee99;
        }
        
        .chart-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid rgba(51, 255, 51, 0.5);
            padding: 20px 10px;
            min-height: 300px;
            max-height: calc(100% - 150px); /* Account for test info */
            overflow: hidden;
        }
        
        /* Styles for the measurement in progress indicator */
        .test-in-progress {
            margin-top: 5px;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            border: 1px solid #33ff33;
        }
        
        .measuring-indicator {
            color: #ffcc00;
            font-weight: bold;
            text-align: center;
            animation: blink 1s infinite alternate;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
        }
        
        @keyframes blink {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        /* Terminal effects */
        .terminal-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            pointer-events: none;
        }
        
        /* Vignette effect */
        .terminal-effects::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 75%, rgba(0, 0, 0, 0.6) 100%);
            z-index: -1;
        }
        
        /* Terminal header elements */
        .terminal-header {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: 'VT323', monospace;
            color: #33ff33;
            display: flex;
            gap: 20px;
            opacity: 0.7;
        }
        
        /* Blinking cursor */
        .terminal-cursor {
            display: inline-block;
            background-color: #33ff33;
            width: 10px;
            height: 18px;
            margin-left: 2px;
            animation: cursor-blink 1s step-end infinite;
        }
        
        @keyframes cursor-blink {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        /* Terminal command line */
        .terminal-command {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-family: 'VT323', monospace;
            color: #33ff33;
            opacity: 0.7;
            display: flex;
            align-items: center;
        }
        
        .terminal-command::before {
            content: "root@tinfoilhat:~$ ";
            margin-right: 5px;
        }
        
        /* Labels on boxes for enhanced terminal aesthetic */
        .leaderboard::after {
            content: attr(data-label);
            position: absolute;
            top: -10px;
            left: 20px;
            background: #0a0a0a;
            padding: 0 10px;
            font-size: 0.8em;
            color: #33ff33;
            font-family: 'VT323', monospace;
        }

        /* Add crisp border style */
        .leaderboard, #recent-test, .spectrum-container {
            border: 2px solid #33ff33;
            box-shadow: inset 0 0 7px rgba(51, 255, 51, 0.2);
        }
        
        /* Reset button styles */
        #forceResetBtn {
            position: absolute;
            right: 10px;
            top: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff3333;
            color: #ff3333;
            font-family: 'VT323', monospace;
            font-size: 14px;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            z-index: 10;
            opacity: 0.6;
        }
        
        #forceResetBtn:hover {
            background-color: rgba(50, 0, 0, 0.8);
            opacity: 1;
            box-shadow: 0 0 5px rgba(255, 51, 51, 0.7);
        }
        
        #forceResetBtn:active {
            transform: scale(0.95);
        }
        
        #forceResetBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <!-- Removed navigation links as requested -->
    
    <div class="terminal-effects"></div>
    <div class="terminal-header">
        <span>TINFOIL_HAT OS v2.0</span>
        <span id="terminal-time"></span>
    </div>
    <div class="terminal-command">
        ./run_billboard.sh <span class="terminal-cursor"></span>
    </div>

    <div class="billboard-container">
        <div class="billboard-header">
            <h1>TINFOIL HAT COMPETITION</h1>
        </div>
        <div class="billboard-content">
            <div class="leaderboards-container">
                <div class="leaderboard" data-label="CLASSIC.TXT">
                    <h2>Classic Hats</h2>
                    <table id="classic-leaderboard" class="leaderboard-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Name</th>
                                <th>Attenuation (dB)</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% if leaderboard_classic %}
                                {% for entry in leaderboard_classic %}
                                <tr class="{% if loop.index == 1 %}first-place{% elif loop.index == 2 %}second-place{% elif loop.index == 3 %}third-place{% endif %}">
                                    <td class="rank">{{ loop.index }}</td>
                                    <td>{{ entry.name }}</td>
                                    <td class="attenuation {% if entry.attenuation < 0 %}negative-attenuation{% endif %}">
                                        {{ "%.2f"|format(entry.attenuation) }}
                                    </td>
                                </tr>
                                {% endfor %}
                            {% else %}
                                <tr>
                                    <td colspan="3" class="text-center">No entries yet</td>
                                </tr>
                            {% endif %}
                        </tbody>
                    </table>
                </div>
                <div class="leaderboard" data-label="HYBRID.TXT">
                    <h2>Hybrid Hats</h2>
                    <table id="hybrid-leaderboard" class="leaderboard-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Name</th>
                                <th>Attenuation (dB)</th>
                            </tr>
                        </thead>
                        <tbody>
                            {% if leaderboard_hybrid %}
                                {% for entry in leaderboard_hybrid %}
                                <tr class="{% if loop.index == 1 %}first-place{% elif loop.index == 2 %}second-place{% elif loop.index == 3 %}third-place{% endif %}">
                                    <td class="rank">{{ loop.index }}</td>
                                    <td>{{ entry.name }}</td>
                                    <td class="attenuation {% if entry.attenuation < 0 %}negative-attenuation{% endif %}">
                                        {{ "%.2f"|format(entry.attenuation) }}
                                    </td>
                                </tr>
                                {% endfor %}
                            {% else %}
                                <tr>
                                    <td colspan="3" class="text-center">No entries yet</td>
                                </tr>
                            {% endif %}
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="testing-container">
                <div id="recent-test" data-label="SPECTRUM.DAT">
                    <div class="test-info">
                        {% if recent_test and recent_test['max_id'] %}
                            <div class="contestant-name">{{ recent_test['name'] }}</div>
                            <div class="hat-type">{{ recent_test['hat_type']|capitalize }} Hat</div>
                            <div class="attenuation {% if recent_test['attenuation'] < 0 %}negative-attenuation{% endif %}">
                                {{ "%.2f"|format(recent_test['attenuation']) }} dB
                            </div>
                            <div class="test-date">{{ recent_test['date'] }}</div>
                        {% else %}
                            <div class="contestant-name">No Tests Yet</div>
                            <div class="hat-type">Waiting for data...</div>
                            <div class="attenuation">0.00 dB</div>
                            <div class="test-date">-</div>
                        {% endif %}
                    </div>
                    <div class="chart-container">
                        <canvas id="powerChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Terminal time display
            function updateTerminalTime() {
                const now = new Date();
                const timeStr = now.toLocaleTimeString('en-US', { 
                    hour12: false,
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
                document.getElementById('terminal-time').textContent = timeStr;
            }
            
            // Update time every second
            updateTerminalTime();
            setInterval(updateTerminalTime, 1000);

            // Initialize charts
            const powerCtx = document.getElementById('powerChart').getContext('2d');
            
            // Initialize with empty data initially
            const emptyData = {
                labels: [],
                datasets: []
            };
            
            // Power Chart (showing both baseline and hat readings, along with attenuation)
            const powerChart = new Chart(powerCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Baseline (dBm)',
                            data: [],
                            borderColor: 'rgba(51, 255, 51, 0.8)',
                            backgroundColor: 'rgba(51, 255, 51, 0.1)',
                            tension: 0.2,
                            borderWidth: 2,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y'
                        }, 
                        {
                            label: 'With Hat (dBm)',
                            data: [],
                            borderColor: 'rgba(0, 200, 255, 0.8)',
                            backgroundColor: 'rgba(0, 200, 255, 0.1)',
                            tension: 0.2,
                            borderWidth: 2,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Attenuation (dB)',
                            data: [],
                            borderColor: 'rgba(255, 204, 0, 0.8)',
                            backgroundColor: 'rgba(255, 204, 0, 0.1)',
                            tension: 0.2,
                            borderWidth: 2,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'attenuation'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'RF SPECTRUM ANALYSIS',
                            color: '#33ff33',
                            font: {
                                size: 18,
                                family: "'Press Start 2P', cursive",
                                weight: 'bold'
                            },
                            padding: {
                                top: 10,
                                bottom: 20
                            }
                        },
                        legend: {
                            labels: {
                                color: '#33ff33',
                                font: {
                                    family: "'VT323', monospace",
                                    size: 18
                                },
                                boxWidth: 15,
                                padding: 15
                            }
                        },
                        tooltip: {
                            titleFont: {
                                family: "'VT323', monospace",
                                size: 18
                            },
                            bodyFont: {
                                family: "'VT323', monospace",
                                size: 17
                            },
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            borderColor: '#33ff33',
                            borderWidth: 1,
                            padding: 12,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.datasetIndex === 2) {
                                        // Attenuation dataset
                                        const value = context.parsed.y;
                                        const colorCode = value < 0 ? 'üî¥' : 'üü¢'; // Red for negative, green for positive
                                        return `${label}${value.toFixed(2)} dB ${colorCode}`;
                                    } else {
                                        return `${label}${context.parsed.y.toFixed(2)} dBm`;
                                    }
                                },
                                title: function(tooltipItems) {
                                    const freq = tooltipItems[0].label;
                                    if (freq) {
                                        return `${freq} MHz`;
                                    }
                                    return '';
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'FREQUENCY (MHz)',
                                color: '#33ff33',
                                font: {
                                    family: "'VT323', monospace",
                                    size: 18
                                },
                                padding: {
                                    top: 10
                                }
                            },
                            ticks: {
                                color: '#33ff33',
                                font: {
                                    family: "'VT323', monospace",
                                    size: 16
                                },
                                maxRotation: 45,
                                minRotation: 45,
                                callback: function(value, index, values) {
                                    const freq = powerChart.data.labels[index];
                                    if (!freq) return '';
                                    
                                    // Handle "0.0" values specially - they are likely a placeholder
                                    if (freq === "0.0" || freq === 0.0) {
                                        // Try to use the last known good frequencies if available
                                        if (currentTestData && currentTestData.frequencies && currentTestData.frequencies.length > index) {
                                            const validFreq = currentTestData.frequencies[index].toFixed(1);
                                            console.log(`Replaced "0.0" with ${validFreq} from saved data at index ${index}`);
                                            return validFreq;
                                        }
                                    }
                                    
                                    return freq;
                                }
                            },
                            grid: {
                                color: 'rgba(51, 255, 51, 0.08)',
                                tickBorderDash: [4, 4]
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'SIGNAL LEVEL (dBm)',
                                color: '#33ff33',
                                font: {
                                    family: "'VT323', monospace",
                                    size: 18
                                },
                                padding: {
                                    bottom: 10
                                }
                            },
                            ticks: {
                                color: '#33ff33',
                                font: {
                                    family: "'VT323', monospace",
                                    size: 16
                                }
                            },
                            grid: {
                                color: 'rgba(51, 255, 51, 0.08)',
                                tickBorderDash: [4, 4]
                            },
                            min: -100,
                            max: -60
                        },
                        attenuation: {
                            position: 'right',
                            title: {
                                display: true,
                                text: 'ATTENUATION (dB)',
                                color: '#ffcc00',
                                font: {
                                    family: "'VT323', monospace",
                                    size: 18
                                },
                                padding: {
                                    bottom: 10
                                }
                            },
                            ticks: {
                                color: '#ffcc00',
                                font: {
                                    family: "'VT323', monospace",
                                    size: 16
                                }
                            },
                            grid: {
                                drawOnChartArea: false,
                                color: 'rgba(255, 204, 0, 0.08)',
                                tickBorderDash: [4, 4]
                            },
                            min: -10,
                            max: 10
                        }
                    }
                }
            });
            
            // Call updateChartCallbacks to apply our callback functions with window.frequencyLabels
            updateChartCallbacks();
            
            // Initialize with global frequency labels from the server if available
            window.frequencyLabels = {};
            {% if frequency_labels %}
                window.frequencyLabels = {{ frequency_labels|tojson }};
            {% endif %}
            
            // Initialize charts with existing data if available
            {% if spectrum_data and spectrum_data.frequencies %}
                // Ensure frequencies are properly formatted as numbers
                const frequencies = {{ spectrum_data.frequencies|tojson }};
                const frequencyLabels = frequencies.map(f => {
                    // Convert to number if it's a string
                    const fNum = typeof f === 'string' ? parseFloat(f) : f;
                    return fNum.toFixed(1);
                });
                const baselineLevels = {{ spectrum_data.baseline_levels|tojson }};
                const hatLevels = {{ spectrum_data.hat_levels|tojson }};
                const attenuations = {{ spectrum_data.attenuations|tojson }};
                
                console.log("Initial frequencies:", frequencyLabels);
                
                // Update power chart
                powerChart.data.labels = frequencyLabels;
                powerChart.data.datasets[0].data = baselineLevels;
                powerChart.data.datasets[1].data = hatLevels;
                powerChart.data.datasets[2].data = attenuations;
                powerChart.update();
            {% endif %}
            
            // Connect to SSE endpoint for real-time updates
            let lastId = {% if recent_test and recent_test['max_id'] %}{{ recent_test['max_id'] }}{% else %}0{% endif %};
            let usePolling = false;
            let eventSource;
            let frequencyEventSource;
            
            // Create objects to store the current test data as it's being measured
            let currentTestData = {
                frequencies: [],
                baseline_levels: [],
                hat_levels: [],
                attenuations: [],
                measurement_type: null,
                contestant_id: null,
                contestant_name: null,
                hat_type: null,
                baseline_in_progress: false
            };
            
            function setupSSE() {
                try {
                    // Main leaderboard updates
                    eventSource = new EventSource(`/billboard-updates?last_id=${lastId}`);
                    
                    eventSource.onmessage = function(event) {
                        const data = JSON.parse(event.data);
                        console.log('Received SSE message:', data); // Add logging to help debug
                        updateBillboard(data);
                        lastId = data.last_id;
                    };
                    
                    eventSource.onerror = function(e) {
                        console.log('SSE connection error, falling back to polling...');
                        eventSource.close();
                        usePolling = true;
                        startPolling();
                    };
                    
                    // Real-time frequency measurement updates
                    frequencyEventSource = new EventSource('/frequency-stream');
                    
                    frequencyEventSource.onmessage = function(event) {
                        const data = JSON.parse(event.data);
                        console.log('Frequency stream event received:', data); // Add logging for all frequency stream events
                        
                        // First, check if this is a reset event (highest priority)
                        if (data.event_type === 'clear_all' || data.event_type === 'test_reset') {
                            console.log("üö® CRITICAL: Direct reset event received via frequency stream - performing IMMEDIATE reset");
                            
                            // Check for emergency flag which indicates highest-priority reset
                            if (data.emergency === true) {
                                console.log("üî•üî•üî• EMERGENCY RESET DETECTED - FORCING IMMEDIATE CHART RESET üî•üî•üî•");
                                
                                // Create a highly visible emergency notification
                                const emergencyNotice = document.createElement('div');
                                emergencyNotice.textContent = 'EMERGENCY RESET - NEW BASELINE TEST STARTED';
                                emergencyNotice.style.position = 'fixed';
                                emergencyNotice.style.top = '50%';
                                emergencyNotice.style.left = '50%';
                                emergencyNotice.style.transform = 'translate(-50%, -50%)';
                                emergencyNotice.style.backgroundColor = '#ff0000';
                                emergencyNotice.style.color = 'white';
                                emergencyNotice.style.padding = '20px';
                                emergencyNotice.style.fontSize = '24px';
                                emergencyNotice.style.fontWeight = 'bold';
                                emergencyNotice.style.zIndex = '9999';
                                emergencyNotice.style.borderRadius = '10px';
                                document.body.appendChild(emergencyNotice);
                                
                                // Remove after 5 seconds
                                setTimeout(() => {
                                    if (emergencyNotice.parentNode) {
                                        emergencyNotice.parentNode.removeChild(emergencyNotice);
                                    }
                                }, 5000);
                            }
                            
                            // Perform the reset
                            currentTestData = {
                                frequencies: [],
                                baseline_levels: [],
                                hat_levels: [],
                                attenuations: [],
                                measurement_type: null,
                                contestant_id: null,
                                contestant_name: null,
                                hat_type: null,
                                baseline_in_progress: false
                            };
                            
                            // Reset chart data
                            powerChart.data.labels = [];
                            powerChart.data.datasets[0].data = [];
                            powerChart.data.datasets[1].data = [];
                            powerChart.data.datasets[2].data = [];
                            powerChart.update();
                            
                            // Update the UI
                            const recentTest = document.getElementById('recent-test');
                            const testInfo = recentTest.querySelector('.test-info');
                            
                            // Check if this is a baseline test start
                            if (data.baseline_start === true || (data.new_test && data.new_test.is_baseline_start === true)) {
                                // Show baseline in progress message
                                testInfo.innerHTML = `
                                    <div class="contestant-name">BASELINE TEST</div>
                                    <div class="hat-type">Baseline Measurement in Progress</div>
                                    <div class="attenuation">0.00 dB</div>
                                    <div class="test-date">In Progress</div>
                                `;
                                
                                // Add a baseline in progress indicator
                                const testInProgress = document.createElement('div');
                                testInProgress.className = 'test-in-progress';
                                testInProgress.innerHTML = '<div class="measuring-indicator">BASELINE IN PROGRESS</div>';
                                testInfo.appendChild(testInProgress);
                                
                                // Set baseline_in_progress flag
                                currentTestData.measurement_type = 'baseline';
                                currentTestData.baseline_in_progress = true;
                            } else {
                                // Standard reset message
                                testInfo.innerHTML = `
                                    <div class="contestant-name">DATA RESET</div>
                                    <div class="hat-type">Waiting for new measurements</div>
                                    <div class="attenuation">0.00 dB</div>
                                    <div class="test-date">All previous data cleared</div>
                                `;
                            }
                            
                            // Remove any existing measurement indicators (only if not a baseline start)
                            if (!(data.baseline_start === true || (data.new_test && data.new_test.is_baseline_start === true))) {
                                const testInProgress = document.querySelector('.test-in-progress');
                                if (testInProgress) {
                                    testInProgress.remove();
                                }
                            }
                            
                            return;
                        }
                        
                        // Check for test completion events
                        if (data.event_type === 'test_complete') {
                            console.log("üèÜ TEST COMPLETION EVENT RECEIVED in frequency stream handler");
                            
                            // Update recent test display
                            const recentTest = document.getElementById('recent-test');
                            const testInfo = recentTest.querySelector('.test-info');
                            testInfo.innerHTML = `
                                <div class="contestant-name">${data.contestant_name || "Unknown"}</div>
                                <div class="hat-type">${data.hat_type ? (data.hat_type.charAt(0).toUpperCase() + data.hat_type.slice(1)) : "Classic"} Hat</div>
                                <div class="attenuation ${data.average_attenuation < 0 ? 'negative-attenuation' : ''}">
                                    ${parseFloat(data.average_attenuation).toFixed(2)} dB
                                </div>
                                <div class="test-date">${new Date().toLocaleString()}</div>
                            `;
                            
                            // Update leaderboards if they're included in the event
                            if (data.leaderboard_classic) {
                                updateLeaderboard('classic', data.leaderboard_classic);
                            }
                            
                            if (data.leaderboard_hybrid) {
                                updateLeaderboard('hybrid', data.leaderboard_hybrid);
                            }
                            
                            // Remove any "in progress" indicators
                            const testInProgress = document.querySelector('.test-in-progress');
                            if (testInProgress) {
                                testInProgress.remove();
                            }
                            
                            return;
                        }
                        
                        // Continue with normal event processing...
                        if (data.event_type === 'billboard_update') {
                            // This is a special update for the billboard with spectrum data
                            console.log('Billboard update received:', data);
                            
                            // If this update includes spectrum data, update the chart
                            if (data.spectrum_data) {
                                // Check if this is a reset event
                                if (data.spectrum_data.test_state === "reset") {
                                    console.log("CRITICAL: Billboard reset event received - clearing all chart data");
                                    
                                    // Force a complete reset of chart data
                                    powerChart.data.labels = [];
                                    powerChart.data.datasets[0].data = [];
                                    powerChart.data.datasets[1].data = [];
                                    powerChart.data.datasets[2].data = [];
                                    powerChart.update();
                                    
                                    // Force reset of all test data in memory
                                    currentTestData = {
                                        frequencies: [],
                                        baseline_levels: [],
                                        hat_levels: [],
                                        attenuations: [],
                                        measurement_type: null,
                                        contestant_id: null,
                                        contestant_name: null,
                                        hat_type: null,
                                        baseline_in_progress: false
                                    };
                                    
                                    // Show reset state in the UI
                                    const recentTest = document.getElementById('recent-test');
                                    const testInfo = recentTest.querySelector('.test-info');
                                    
                                    // Check if this is a baseline test start
                                    if (data.baseline_start === true || (data.new_test && data.new_test.is_baseline_start === true)) {
                                        // Show baseline in progress message
                                        testInfo.innerHTML = `
                                            <div class="contestant-name">BASELINE TEST</div>
                                            <div class="hat-type">Baseline Measurement in Progress</div>
                                            <div class="attenuation">0.00 dB</div>
                                            <div class="test-date">In Progress</div>
                                        `;
                                        
                                        // Add a baseline in progress indicator
                                        const testInProgress = document.createElement('div');
                                        testInProgress.className = 'test-in-progress';
                                        testInProgress.innerHTML = '<div class="measuring-indicator">BASELINE IN PROGRESS</div>';
                                        testInfo.appendChild(testInProgress);
                                        
                                        // Set baseline_in_progress flag
                                        currentTestData.measurement_type = 'baseline';
                                        currentTestData.baseline_in_progress = true;
                                    } else {
                                        // Standard reset message
                                        testInfo.innerHTML = `
                                            <div class="contestant-name">DATA RESET</div>
                                            <div class="hat-type">Waiting for new measurements</div>
                                            <div class="attenuation">0.00 dB</div>
                                            <div class="test-date">All previous data cleared</div>
                                        `;
                                    }
                                    
                                    // Remove any existing measurement indicators (only if not a baseline start)
                                    if (!(data.baseline_start === true || (data.new_test && data.new_test.is_baseline_start === true))) {
                                        const testInProgress = document.querySelector('.test-in-progress');
                                        if (testInProgress) {
                                            testInProgress.remove();
                                        }
                                    }
                                    
                                    return;
                                }
                                // Update with new spectrum data if it contains frequencies
                                else if (data.spectrum_data.frequencies && data.spectrum_data.frequencies.length > 0) {
                                    // Use the provided spectrum data to update the chart
                                    const spectrumData = data.spectrum_data;
                                    
                                    // Update chart data
                                    powerChart.data.labels = spectrumData.frequencies.map(f => f.toFixed(1));
                                    powerChart.data.datasets[0].data = spectrumData.baseline_levels;
                                    powerChart.data.datasets[1].data = spectrumData.hat_levels;
                                    powerChart.data.datasets[2].data = spectrumData.attenuations;
                                    powerChart.update();
                                    
                                    // Also update currentTestData
                                    currentTestData.frequencies = [...spectrumData.frequencies];
                                    currentTestData.baseline_levels = [...spectrumData.baseline_levels];
                                    currentTestData.hat_levels = [...spectrumData.hat_levels];
                                    currentTestData.attenuations = [...spectrumData.attenuations];
                                }
                            }
                            
                            return;
                        }
                        
                        // This is a single frequency measurement update
                        console.log('Frequency update:', data);
                        
                        // Store the contestant information if available
                        if (data.contestant_id && !currentTestData.contestant_id) {
                            currentTestData.contestant_id = data.contestant_id;
                        }
                        
                        // Store contestant name and hat type if available
                        if (data.contestant_name) {
                            currentTestData.contestant_name = data.contestant_name;
                        }
                        
                        if (data.hat_type) {
                            currentTestData.hat_type = data.hat_type;
                        }
                        
                        // Update measurement type
                        currentTestData.measurement_type = data.measurement_type;
                        
                        // IMPORTANT FIX: Check if this is the first baseline measurement of a new test
                        // If we receive a baseline measurement and we don't have a baseline test in progress, 
                        // this indicates the start of a new baseline test - we should reset data
                        if (data.measurement_type === 'baseline' && 
                            (currentTestData.frequencies.length === 0 || 
                             data.first_measurement === true || 
                             (currentTestData.hat_levels.some(level => level !== null) && !currentTestData.baseline_in_progress))) {
                            
                            console.log("üîÑ First baseline measurement detected - clearing all previous data");
                            
                            // Force a complete reset of all chart data
                            powerChart.data.labels = [];
                            powerChart.data.datasets[0].data = [];
                            powerChart.data.datasets[1].data = [];
                            powerChart.data.datasets[2].data = [];
                            powerChart.update();
                            
                            // Reset the current test data
                            currentTestData = {
                                frequencies: [],
                                baseline_levels: [],
                                hat_levels: [],
                                attenuations: [],
                                measurement_type: 'baseline',
                                contestant_id: data.contestant_id || null,
                                contestant_name: data.contestant_name || "Baseline Measurement",
                                hat_type: data.hat_type || null,
                                baseline_in_progress: true
                            };
                            
                            // Update UI to indicate new baseline test
                            const recentTest = document.getElementById('recent-test');
                            const testInfo = recentTest.querySelector('.test-info');
                            testInfo.innerHTML = `
                                <div class="contestant-name">NEW BASELINE TEST</div>
                                <div class="hat-type">Starting baseline measurement...</div>
                                <div class="attenuation">0.00 dB</div>
                                <div class="test-date">In Progress</div>
                            `;
                            
                            // Add the "measurement in progress" indicator
                            const testInProgress = document.createElement('div');
                            testInProgress.className = 'test-in-progress';
                            testInProgress.innerHTML = '<div class="measuring-indicator">NEW BASELINE IN PROGRESS</div>';
                            testInfo.appendChild(testInProgress);
                        }
                        
                        // Process based on measurement type
                        if (data.measurement_type === 'baseline') {
                            // Set the baseline in progress flag
                            currentTestData.baseline_in_progress = true;
                        
                            // Store baseline measurement
                            const freqIndex = currentTestData.frequencies.indexOf(data.frequency_mhz);
                            if (freqIndex === -1) {
                                // New frequency
                                currentTestData.frequencies.push(data.frequency_mhz);
                                currentTestData.baseline_levels.push(data.power);
                                
                                // Sort the arrays by frequency
                                const sortIndices = [...currentTestData.frequencies.keys()]
                                    .sort((a, b) => currentTestData.frequencies[a] - currentTestData.frequencies[b]);
                                
                                currentTestData.frequencies = sortIndices.map(i => currentTestData.frequencies[i]);
                                currentTestData.baseline_levels = sortIndices.map(i => currentTestData.baseline_levels[i]);
                                
                                // Add placeholder null values for hat and attenuation
                                if (currentTestData.hat_levels.length < currentTestData.frequencies.length) {
                                    currentTestData.hat_levels.push(null);
                                    currentTestData.attenuations.push(null);
                                }
                            } else {
                                // Update existing frequency
                                currentTestData.baseline_levels[freqIndex] = data.power;
                            }
                        } else if (data.measurement_type === 'hat') {
                            // If we're switching from baseline to hat, update the flag
                            if (currentTestData.baseline_in_progress) {
                                currentTestData.baseline_in_progress = false;
                            }
                            
                            // Store hat measurement and attenuation if available
                            const freqIndex = currentTestData.frequencies.indexOf(data.frequency_mhz);
                            if (freqIndex === -1) {
                                // New frequency
                                currentTestData.frequencies.push(data.frequency_mhz);
                                currentTestData.hat_levels.push(data.power);
                                currentTestData.attenuations.push(data.attenuation || null);
                                
                                // Add placeholder null value for baseline if needed
                                if (currentTestData.baseline_levels.length < currentTestData.frequencies.length) {
                                    currentTestData.baseline_levels.push(null);
                                }
                                
                                // Sort the arrays by frequency
                                const sortIndices = [...currentTestData.frequencies.keys()]
                                    .sort((a, b) => currentTestData.frequencies[a] - currentTestData.frequencies[b]);
                                
                                currentTestData.frequencies = sortIndices.map(i => currentTestData.frequencies[i]);
                                currentTestData.baseline_levels = sortIndices.map(i => currentTestData.baseline_levels[i]);
                                currentTestData.hat_levels = sortIndices.map(i => currentTestData.hat_levels[i]);
                                currentTestData.attenuations = sortIndices.map(i => currentTestData.attenuations[i]);
                            } else {
                                // Update existing frequency
                                currentTestData.hat_levels[freqIndex] = data.power;
                                currentTestData.attenuations[freqIndex] = data.attenuation || null;
                            }
                        }
                        
                        // For debugging, log the state of currentTestData
                        console.log("Current test data updated, frequencies:", currentTestData.frequencies.length);
                        
                        // Update the recent test information with current test data
                        updateRecentTestWithCurrentData();
                        
                        // Update the charts with the real-time data
                        updateChartsWithLiveData();
                    };
                    
                    frequencyEventSource.onerror = function(e) {
                        console.log('Frequency stream connection error');
                        frequencyEventSource.close();
                        // Try to reconnect after a short delay
                        setTimeout(() => {
                            frequencyEventSource = new EventSource('/frequency-stream');
                        }, 3000);
                    };
                } catch (e) {
                    console.log('Error setting up SSE, falling back to polling:', e);
                    usePolling = true;
                    startPolling();
                }
            }
            
            // Event handlers for data streaming
            function handleFrequencyUpdate(data) {
                // Always log all incoming events for debugging
                console.log(`Frequency event received type=${data.event_type || 'unknown'}:`, data);
                
                // Check if this is a reset or clear event - THIS IS HIGHEST PRIORITY
                if (data.event_type === 'test_reset' || data.event_type === 'clear_all' || 
                    (data.event_type === 'billboard_update' && data.spectrum_data && data.spectrum_data.test_state === 'reset')) {
                    
                    // Log the event with high visibility
                    console.log(`‚òÖ‚òÖ‚òÖ ${data.event_type.toUpperCase()}: CRITICAL RESET EVENT RECEIVED ‚òÖ‚òÖ‚òÖ`, data);
                    console.log(`‚òÖ‚òÖ‚òÖ FORCING COMPLETE CHART DATA RESET ‚òÖ‚òÖ‚òÖ`);
                    
                    // GUARANTEED RESET: Reset currentTestData to completely empty state
                    currentTestData = {
                        frequencies: [],
                        baseline_levels: [],
                        hat_levels: [],
                        attenuations: [],
                        measurement_type: null,
                        contestant_id: null,
                        contestant_name: null,
                        hat_type: null,
                        baseline_in_progress: false
                    };
                    
                    // Reset chart data with forced update
                    powerChart.data.labels = [];
                    powerChart.data.datasets[0].data = [];
                    powerChart.data.datasets[1].data = [];
                    powerChart.data.datasets[2].data = [];
                    powerChart.update();
                    
                    // Update the recent test display to show reset state with visual feedback
                    const recentTest = document.getElementById('recent-test');
                    const testInfo = recentTest.querySelector('.test-info');
                    
                    // Use slightly different messages based on event type
                    const titleText = data.event_type === 'clear_all' ? 'NEW BASELINE TEST' : 'NEW TEST';
                    const subtitleText = data.event_type === 'clear_all' ? 'Starting baseline measurement...' : 'Ready for measurement';
                    
                    testInfo.innerHTML = `
                        <div class="contestant-name">${titleText}</div>
                        <div class="hat-type">${subtitleText}</div>
                        <div class="attenuation">0.00 dB</div>
                        <div class="test-date">Previous data cleared</div>
                    `;
                    
                    // Remove any existing measurement indicators
                    const testInProgress = document.querySelector('.test-in-progress');
                    if (testInProgress) {
                        testInProgress.remove();
                    }
                    
                    // Show a "test reset" indicator with bright colors
                    const resetIndicator = document.createElement('div');
                    resetIndicator.className = 'test-reset-indicator';
                    resetIndicator.textContent = data.event_type === 'clear_all' ? 
                        'ALL DATA CLEARED - NEW BASELINE TEST STARTING' : 
                        'TEST RESET - ALL PREVIOUS DATA CLEARED';
                    resetIndicator.style.color = '#ffcc00';
                    resetIndicator.style.fontWeight = 'bold';
                    resetIndicator.style.textAlign = 'center';
                    resetIndicator.style.padding = '10px';
                    resetIndicator.style.marginTop = '10px';
                    resetIndicator.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    resetIndicator.style.border = '2px solid #ff5500';
                    resetIndicator.style.borderRadius = '5px';
                    testInfo.appendChild(resetIndicator);
                    
                    // Remove the indicator after 8 seconds (longer display for more visibility)
                    setTimeout(() => {
                        if (resetIndicator && resetIndicator.parentNode) {
                            resetIndicator.parentNode.removeChild(resetIndicator);
                        }
                    }, 8000);
                    
                    console.log("Reset UI updated - indicator added to display");
                    return;
                } else if (data.event_type === 'test_complete') {
                    // This is a final test result
                    console.log('Test complete event received:', data);
                    
                    // Important: Do not reset or modify current test data or chart
                    // The billboard update will handle the leaderboard/recent test updates
                    // but we'll preserve the current chart data as-is since it likely has better frequency info
                    
                    // Mark the current state as completed but don't change the data
                    console.log("Test complete - preserving current chart data");
                    
                    // Update the UI to remove the "in progress" indicator without changing chart data
                    const testInProgress = document.querySelector('.test-in-progress');
                    if (testInProgress) {
                        testInProgress.remove();
                    }
                    
                    return;
                } else if (data.event_type === 'billboard_update') {
                    // This is a special update for the billboard with spectrum data
                    console.log('Billboard update received:', data);
                    
                    // If this update includes spectrum data, update the chart
                    if (data.spectrum_data) {
                        // Check if this is a reset event
                        if (data.spectrum_data.test_state === "reset") {
                            console.log("CRITICAL: Billboard reset event received - clearing all chart data");
                            
                            // Force a complete reset of chart data
                            powerChart.data.labels = [];
                            powerChart.data.datasets[0].data = [];
                            powerChart.data.datasets[1].data = [];
                            powerChart.data.datasets[2].data = [];
                            powerChart.update();
                            
                            // Force reset of all test data in memory
                            currentTestData = {
                                frequencies: [],
                                baseline_levels: [],
                                hat_levels: [],
                                attenuations: [],
                                measurement_type: null,
                                contestant_id: null,
                                contestant_name: null,
                                hat_type: null,
                                baseline_in_progress: false
                            };
                            
                            // Show reset state in the UI
                            const recentTest = document.getElementById('recent-test');
                            const testInfo = recentTest.querySelector('.test-info');
                            
                            // Check if this is a baseline test start
                            if (data.baseline_start === true || (data.new_test && data.new_test.is_baseline_start === true)) {
                                // Show baseline in progress message
                                testInfo.innerHTML = `
                                    <div class="contestant-name">BASELINE TEST</div>
                                    <div class="hat-type">Baseline Measurement in Progress</div>
                                    <div class="attenuation">0.00 dB</div>
                                    <div class="test-date">In Progress</div>
                                `;
                                
                                // Add a baseline in progress indicator
                                const testInProgress = document.createElement('div');
                                testInProgress.className = 'test-in-progress';
                                testInProgress.innerHTML = '<div class="measuring-indicator">BASELINE IN PROGRESS</div>';
                                testInfo.appendChild(testInProgress);
                                
                                // Set baseline_in_progress flag
                                currentTestData.measurement_type = 'baseline';
                                currentTestData.baseline_in_progress = true;
                            } else {
                                // Standard reset message
                                testInfo.innerHTML = `
                                    <div class="contestant-name">DATA RESET</div>
                                    <div class="hat-type">Waiting for new measurements</div>
                                    <div class="attenuation">0.00 dB</div>
                                    <div class="test-date">All previous data cleared</div>
                                `;
                            }
                            
                            // Remove any existing measurement indicators (only if not a baseline start)
                            if (!(data.baseline_start === true || (data.new_test && data.new_test.is_baseline_start === true))) {
                                const testInProgress = document.querySelector('.test-in-progress');
                                if (testInProgress) {
                                    testInProgress.remove();
                                }
                            }
                            
                            return;
                        }
                        // Update with new spectrum data if it contains frequencies
                        else if (data.spectrum_data.frequencies && data.spectrum_data.frequencies.length > 0) {
                            // Use the provided spectrum data to update the chart
                            const spectrumData = data.spectrum_data;
                            
                            // Update chart data
                            powerChart.data.labels = spectrumData.frequencies.map(f => f.toFixed(1));
                            powerChart.data.datasets[0].data = spectrumData.baseline_levels;
                            powerChart.data.datasets[1].data = spectrumData.hat_levels;
                            powerChart.data.datasets[2].data = spectrumData.attenuations;
                            powerChart.update();
                            
                            // Also update currentTestData
                            currentTestData.frequencies = [...spectrumData.frequencies];
                            currentTestData.baseline_levels = [...spectrumData.baseline_levels];
                            currentTestData.hat_levels = [...spectrumData.hat_levels];
                            currentTestData.attenuations = [...spectrumData.attenuations];
                        }
                    }
                    
                    return;
                }
                
                // This is a single frequency measurement update
                console.log('Frequency update:', data);
                
                // Store the contestant information if available
                if (data.contestant_id && !currentTestData.contestant_id) {
                    currentTestData.contestant_id = data.contestant_id;
                }
                
                // Store contestant name and hat type if available
                if (data.contestant_name) {
                    currentTestData.contestant_name = data.contestant_name;
                }
                
                if (data.hat_type) {
                    currentTestData.hat_type = data.hat_type;
                }
                
                // Update measurement type
                currentTestData.measurement_type = data.measurement_type;
                
                // IMPORTANT FIX: Check if this is the first baseline measurement of a new test
                // If we receive a baseline measurement and we don't have a baseline test in progress, 
                // this indicates the start of a new baseline test - we should reset data
                if (data.measurement_type === 'baseline' && 
                    (currentTestData.frequencies.length === 0 || 
                     data.first_measurement === true || 
                     (currentTestData.hat_levels.some(level => level !== null) && !currentTestData.baseline_in_progress))) {
                    
                    console.log("üîÑ First baseline measurement detected - clearing all previous data");
                    
                    // Force a complete reset of all chart data
                    powerChart.data.labels = [];
                    powerChart.data.datasets[0].data = [];
                    powerChart.data.datasets[1].data = [];
                    powerChart.data.datasets[2].data = [];
                    powerChart.update();
                    
                    // Reset the current test data
                    currentTestData = {
                        frequencies: [],
                        baseline_levels: [],
                        hat_levels: [],
                        attenuations: [],
                        measurement_type: 'baseline',
                        contestant_id: data.contestant_id || null,
                        contestant_name: data.contestant_name || "Baseline Measurement",
                        hat_type: data.hat_type || null,
                        baseline_in_progress: true
                    };
                    
                    // Update UI to indicate new baseline test
                    const recentTest = document.getElementById('recent-test');
                    const testInfo = recentTest.querySelector('.test-info');
                    testInfo.innerHTML = `
                        <div class="contestant-name">NEW BASELINE TEST</div>
                        <div class="hat-type">Starting baseline measurement...</div>
                        <div class="attenuation">0.00 dB</div>
                        <div class="test-date">In Progress</div>
                    `;
                    
                    // Add the "measurement in progress" indicator
                    const testInProgress = document.createElement('div');
                    testInProgress.className = 'test-in-progress';
                    testInProgress.innerHTML = '<div class="measuring-indicator">NEW BASELINE IN PROGRESS</div>';
                    testInfo.appendChild(testInProgress);
                }
                
                // Process based on measurement type
                if (data.measurement_type === 'baseline') {
                    // Set the baseline in progress flag
                    currentTestData.baseline_in_progress = true;
                
                    // Store baseline measurement
                    const freqIndex = currentTestData.frequencies.indexOf(data.frequency_mhz);
                    if (freqIndex === -1) {
                        // New frequency
                        currentTestData.frequencies.push(data.frequency_mhz);
                        currentTestData.baseline_levels.push(data.power);
                        
                        // Sort the arrays by frequency
                        const sortIndices = [...currentTestData.frequencies.keys()]
                            .sort((a, b) => currentTestData.frequencies[a] - currentTestData.frequencies[b]);
                        
                        currentTestData.frequencies = sortIndices.map(i => currentTestData.frequencies[i]);
                        currentTestData.baseline_levels = sortIndices.map(i => currentTestData.baseline_levels[i]);
                        
                        // Add placeholder null values for hat and attenuation
                        if (currentTestData.hat_levels.length < currentTestData.frequencies.length) {
                            currentTestData.hat_levels.push(null);
                            currentTestData.attenuations.push(null);
                        }
                    } else {
                        // Update existing frequency
                        currentTestData.baseline_levels[freqIndex] = data.power;
                    }
                } else if (data.measurement_type === 'hat') {
                    // If we're switching from baseline to hat, update the flag
                    if (currentTestData.baseline_in_progress) {
                        currentTestData.baseline_in_progress = false;
                    }
                    
                    // Store hat measurement and attenuation if available
                    const freqIndex = currentTestData.frequencies.indexOf(data.frequency_mhz);
                    if (freqIndex === -1) {
                        // New frequency
                        currentTestData.frequencies.push(data.frequency_mhz);
                        currentTestData.hat_levels.push(data.power);
                        currentTestData.attenuations.push(data.attenuation || null);
                        
                        // Add placeholder null value for baseline if needed
                        if (currentTestData.baseline_levels.length < currentTestData.frequencies.length) {
                            currentTestData.baseline_levels.push(null);
                        }
                        
                        // Sort the arrays by frequency
                        const sortIndices = [...currentTestData.frequencies.keys()]
                            .sort((a, b) => currentTestData.frequencies[a] - currentTestData.frequencies[b]);
                        
                        currentTestData.frequencies = sortIndices.map(i => currentTestData.frequencies[i]);
                        currentTestData.baseline_levels = sortIndices.map(i => currentTestData.baseline_levels[i]);
                        currentTestData.hat_levels = sortIndices.map(i => currentTestData.hat_levels[i]);
                        currentTestData.attenuations = sortIndices.map(i => currentTestData.attenuations[i]);
                    } else {
                        // Update existing frequency
                        currentTestData.hat_levels[freqIndex] = data.power;
                        currentTestData.attenuations[freqIndex] = data.attenuation || null;
                    }
                }
                
                // For debugging, log the state of currentTestData
                console.log("Current test data updated, frequencies:", currentTestData.frequencies.length);
                
                // Update the recent test information with current test data
                updateRecentTestWithCurrentData();
                
                // Update the charts with the real-time data
                updateChartsWithLiveData();
            }
            
            // Function to update the recent test display
            function updateRecentTest(testData) {
                const recentTest = document.getElementById('recent-test');
                const testInfo = recentTest.querySelector('.test-info');
                
                console.log("Updating recent test display with:", testData);
                
                // No animation class, just update content
                testInfo.innerHTML = `
                    <div class="contestant-name">${testData.name}</div>
                    <div class="hat-type">${testData.hat_type.charAt(0).toUpperCase() + testData.hat_type.slice(1)} Hat</div>
                    <div class="attenuation ${testData.attenuation < 0 ? 'negative-attenuation' : ''}">
                        ${testData.attenuation.toFixed(2)} dB
                    </div>
                    <div class="test-date">${testData.date}</div>
                `;
                
                // IMPORTANT: We DO NOT update the chart data here
                // The spectrum graph will continue to display the streaming data with proper frequency labels
            }
            
            // Function to update the recent test display with current test data
            function updateRecentTestWithCurrentData() {
                const recentTest = document.getElementById('recent-test');
                const testInfo = recentTest.querySelector('.test-info');
                
                // Set contestant name (use "Baseline" if in baseline measurement mode)
                let displayName = "Unknown";
                if (currentTestData.measurement_type === 'baseline') {
                    displayName = "Baseline";
                } else if (currentTestData.contestant_name) {
                    displayName = currentTestData.contestant_name;
                }
                
                // Set hat type
                let hatTypeDisplay = "Measuring...";
                if (currentTestData.hat_type) {
                    hatTypeDisplay = currentTestData.hat_type.charAt(0).toUpperCase() + 
                                    currentTestData.hat_type.slice(1) + " Hat";
                } else if (currentTestData.measurement_type === 'baseline') {
                    hatTypeDisplay = "Baseline Measurement";
                }
                
                // Calculate average attenuation from valid values
                let avgAttenuation = 0;
                let validAttenuations = currentTestData.attenuations.filter(a => a !== null);
                if (validAttenuations.length > 0) {
                    avgAttenuation = validAttenuations.reduce((sum, val) => sum + val, 0) / validAttenuations.length;
                }
                
                // Create HTML for recent test
                testInfo.innerHTML = `
                    <div class="contestant-name">${displayName}</div>
                    <div class="hat-type">${hatTypeDisplay}</div>
                    <div class="attenuation ${avgAttenuation < 0 ? 'negative-attenuation' : ''}">
                        ${avgAttenuation.toFixed(2)} dB
                    </div>
                    <div class="test-date">In Progress</div>
                `;
                
                // Add the "measurement in progress" indicator if it doesn't exist
                if (!recentTest.querySelector('.test-in-progress')) {
                    const testInProgress = document.createElement('div');
                    testInProgress.className = 'test-in-progress';
                    testInProgress.innerHTML = '<div class="measuring-indicator">MEASUREMENT IN PROGRESS</div>';
                    testInfo.appendChild(testInProgress);
                }
            }
            
            // Update charts with the current test data
            function updateChartsWithLiveData() {
                // Don't update if no data available
                if (currentTestData.frequencies.length === 0) {
                    return;
                }
                
                // Update power chart with available data
                const formattedLabels = currentTestData.frequencies.map(f => f.toFixed(1));
                powerChart.data.labels = formattedLabels;
                powerChart.data.datasets[0].data = currentTestData.baseline_levels;
                powerChart.data.datasets[1].data = currentTestData.hat_levels;
                powerChart.data.datasets[2].data = currentTestData.attenuations;
                powerChart.update();
            }
            
            // Function to update chart callbacks to use the window.frequencyLabels
            function updateChartCallbacks() {
                // Update tooltip callback to use window.frequencyLabels
                powerChart.options.plugins.tooltip.callbacks.title = function(tooltipItems) {
                    const freq = tooltipItems[0].label;
                    if (freq) {
                        const freqNum = parseFloat(freq);
                        // Check if we have window.frequencyLabels and use them
                        if (window.frequencyLabels && Object.keys(window.frequencyLabels).length > 0) {
                            for (const [freqMhz, labelData] of Object.entries(window.frequencyLabels)) {
                                if (Math.abs(freqNum - parseFloat(freqMhz)) < 0.1) {
                                    if (labelData[1]) {
                                        return `${freq} MHz (${labelData[0]}) - ${labelData[1]}`;
                                    } else {
                                        return `${freq} MHz (${labelData[0]})`;
                                    }
                                }
                            }
                        }
                        // If no matching label found or no labels available, just show frequency
                        return `${freq} MHz`;
                    }
                    return '';
                };
                
                // Update x-axis tick callback to use window.frequencyLabels
                powerChart.options.scales.x.ticks.callback = function(value, index, values) {
                    const freq = powerChart.data.labels[index];
                    if (!freq) return '';
                    
                    // Make sure freq is a string
                    const freqStr = freq.toString();
                    
                    // Try to get a label for this frequency
                    const freqNum = parseFloat(freqStr);
                    if (window.frequencyLabels && Object.keys(window.frequencyLabels).length > 0) {
                        for (const [freqMhz, labelData] of Object.entries(window.frequencyLabels)) {
                            if (Math.abs(freqNum - parseFloat(freqMhz)) < 0.1) {
                                return `${freqStr} (${labelData[0]})`;
                            }
                        }
                    }
                    
                    // If no label found, use a common band name based on frequency if possible
                    if (freqNum >= 88 && freqNum <= 108) return `${freqStr} (FM)`;
                    if (freqNum >= 470 && freqNum <= 806) return `${freqStr} (UHF)`;
                    if (freqNum >= 2400 && freqNum <= 2500) return `${freqStr} (WiFi)`;
                    if (freqNum >= 5100 && freqNum <= 5800) return `${freqStr} (5G WiFi)`;
                    
                    // Default case, just return the frequency
                    return freqStr;
                };
            }
            
            // Common function to update the billboard with new data
            function updateBillboard(data) {
                // Log the entire data object for debugging
                console.log("============== BILLBOARD UPDATE =============");
                console.log("Received billboard update with data:", data);
                console.log("============================================");
                
                // IMPORTANT FIX: Look for reset indicators in the data
                // Check for explicit reset events or the start of a new baseline test
                const isReset = data.reset === true || 
                               (data.spectrum_data && data.spectrum_data.test_state === 'reset') ||
                               (data.event_type === 'test_reset' || data.event_type === 'clear_all') ||
                               (data.new_test && data.new_test.is_baseline_start === true);
                
                if (isReset) {
                    console.log("üîÑüîÑüîÑ RESET DETECTED IN BILLBOARD UPDATE - CLEARING ALL CHART DATA üîÑüîÑüîÑ");
                    
                    // Force a complete reset of all chart data
                    powerChart.data.labels = [];
                    powerChart.data.datasets[0].data = [];
                    powerChart.data.datasets[1].data = [];
                    powerChart.data.datasets[2].data = [];
                    powerChart.update();
                    
                    // Reset the current test data completely
                    currentTestData = {
                        frequencies: [],
                        baseline_levels: [],
                        hat_levels: [],
                        attenuations: [],
                        measurement_type: null,
                        contestant_id: null,
                        contestant_name: null,
                        hat_type: null,
                        baseline_in_progress: false
                    };
                    
                    // Update UI to indicate reset
                    const recentTest = document.getElementById('recent-test');
                    const testInfo = recentTest.querySelector('.test-info');
                    
                    // Check if this is a baseline test start
                    if (data.baseline_start === true || (data.new_test && data.new_test.is_baseline_start === true)) {
                        // Show baseline in progress message
                        testInfo.innerHTML = `
                            <div class="contestant-name">BASELINE TEST</div>
                            <div class="hat-type">Baseline Measurement in Progress</div>
                            <div class="attenuation">0.00 dB</div>
                            <div class="test-date">In Progress</div>
                        `;
                        
                        // Add a baseline in progress indicator
                        const testInProgress = document.createElement('div');
                        testInProgress.className = 'test-in-progress';
                        testInProgress.innerHTML = '<div class="measuring-indicator">BASELINE IN PROGRESS</div>';
                        testInfo.appendChild(testInProgress);
                        
                        // Set baseline_in_progress flag
                        currentTestData.measurement_type = 'baseline';
                        currentTestData.baseline_in_progress = true;
                    } else {
                        // Standard reset message
                        testInfo.innerHTML = `
                            <div class="contestant-name">DATA RESET</div>
                            <div class="hat-type">Waiting for new measurements</div>
                            <div class="attenuation">0.00 dB</div>
                            <div class="test-date">All previous data cleared</div>
                        `;
                    }
                    
                    // Remove any existing measurement indicators (only if not a baseline start)
                    if (!(data.baseline_start === true || (data.new_test && data.new_test.is_baseline_start === true))) {
                        const testInProgress = document.querySelector('.test-in-progress');
                        if (testInProgress) {
                            testInProgress.remove();
                        }
                    }
                    
                    // Add a visual reset notification
                    const resetNotification = document.createElement('div');
                    resetNotification.className = 'reset-notification';
                    resetNotification.textContent = 'CHART DATA CLEARED FOR NEW TEST';
                    resetNotification.style.color = '#ff5500';
                    resetNotification.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                    resetNotification.style.padding = '10px';
                    resetNotification.style.margin = '10px 0';
                    resetNotification.style.textAlign = 'center';
                    resetNotification.style.fontWeight = 'bold';
                    resetNotification.style.border = '2px solid #ff5500';
                    resetNotification.style.borderRadius = '5px';
                    testInfo.appendChild(resetNotification);
                    
                    // Remove the notification after 5 seconds
                    setTimeout(() => {
                        if (resetNotification && resetNotification.parentNode) {
                            resetNotification.parentNode.removeChild(resetNotification);
                        }
                    }, 5000);
                }
                
                // Check for test completion events
                if (data.event_type === "test_complete") {
                    console.log("üèÜ TEST COMPLETION EVENT RECEIVED - Updating recent test and leaderboards");
                    
                    // Create a test object from the test completion data
                    const testData = {
                        name: data.contestant_name || "Unknown",
                        hat_type: data.hat_type || "classic",
                        attenuation: data.average_attenuation || 0.0,
                        date: new Date().toLocaleString()
                    };
                    
                    // Update the recent test display
                    updateRecentTest(testData);
                    
                    // Remove the "Measurement in Progress" indicator if it exists
                    const testInProgress = document.querySelector('.test-in-progress');
                    if (testInProgress) {
                        testInProgress.remove();
                    }
                }
                
                // Update the recent test display if there's new test data
                if (data.new_test) {
                    updateRecentTest(data.new_test);
                    
                    // Remove the "Measurement in Progress" indicator if it exists
                    const testInProgress = document.querySelector('.test-in-progress');
                    if (testInProgress) {
                        testInProgress.remove();
                    }
                    
                    // IMPORTANT FIX: Modified the data preservation behavior
                    // We now only preserve measurement-specific fields if NOT a reset
                    if (!isReset) {
                        // This is a normal test completion, we can keep frequency data
                        currentTestData.measurement_type = null;
                        currentTestData.contestant_id = null;
                        currentTestData.contestant_name = null;
                        currentTestData.hat_type = null;
                        currentTestData.baseline_in_progress = false;
                        // We keep frequencies[], baseline_levels[], hat_levels[], and attenuations[] intact
                    }
                }
                
                // Update leaderboards
                if (data.leaderboard_classic) {
                    updateLeaderboard('classic', data.leaderboard_classic);
                }
                
                if (data.leaderboard_hybrid) {
                    updateLeaderboard('hybrid', data.leaderboard_hybrid);
                }
                
                // Store frequency labels if available for chart tooltips and axis labels
                if (data.frequency_labels) {
                    console.log("Received frequency labels:", data.frequency_labels);
                    window.frequencyLabels = data.frequency_labels;
                }
                
                // Update charts with spectrum data ONLY if there's meaningful data
                if (data.spectrum_data && Object.keys(data.spectrum_data).length > 0) {
                    console.log("Received spectrum data:", data.spectrum_data);
                    
                    // IMPORTANT FIX: Changed data preservation logic
                    // If this is a reset, we will always update chart (removing old data)
                    // For normal updates, we still preserve good frequency data                    
                    if (!isReset && data.new_test) {
                        // Check if data has missing/bad frequencies
                        const hasBadFrequencies = !data.spectrum_data.frequencies || 
                                                  data.spectrum_data.frequencies.length === 0 || 
                                                  data.spectrum_data.frequencies.every(f => f === 0 || f === '0' || f === '0.0');
                        
                        if (hasBadFrequencies) {
                            console.warn("Test completion data has missing or zero frequencies - keeping current chart display");
                            return; // Don't update the chart at all, keep showing what we already have
                        }
                    }
                    
                    // Create a copy of spectrum data to work with
                    const updatedSpectrumData = {...data.spectrum_data};
                    
                    // Check if frequencies are missing or empty in the incoming data
                    if (!updatedSpectrumData.frequencies || updatedSpectrumData.frequencies.length === 0) {
                        console.warn("Missing frequencies in spectrum data - using saved frequencies from current test data");
                        
                        // Use frequencies from currentTestData if available
                        if (currentTestData.frequencies && currentTestData.frequencies.length > 0) {
                            updatedSpectrumData.frequencies = [...currentTestData.frequencies];
                            console.log("Using saved frequencies:", updatedSpectrumData.frequencies);
                        } else {
                            console.error("No frequency data available - cannot update chart");
                            return;
                        }
                    }
                    
                    // Ensure other required arrays exist and have correct length
                    const freqLength = updatedSpectrumData.frequencies.length;
                    
                    // Check baseline levels
                    if (!updatedSpectrumData.baseline_levels || updatedSpectrumData.baseline_levels.length !== freqLength) {
                        if (currentTestData.baseline_levels && currentTestData.baseline_levels.length === freqLength) {
                            updatedSpectrumData.baseline_levels = [...currentTestData.baseline_levels];
                        } else {
                            updatedSpectrumData.baseline_levels = Array(freqLength).fill(-85); // Default value
                        }
                    }
                    
                    // Check hat levels
                    if (!updatedSpectrumData.hat_levels || updatedSpectrumData.hat_levels.length !== freqLength) {
                        if (currentTestData.hat_levels && currentTestData.hat_levels.length === freqLength) {
                            updatedSpectrumData.hat_levels = [...currentTestData.hat_levels];
                        } else {
                            updatedSpectrumData.hat_levels = Array(freqLength).fill(-85); // Default value
                        }
                    }
                    
                    // Check attenuations
                    if (!updatedSpectrumData.attenuations || updatedSpectrumData.attenuations.length !== freqLength) {
                        if (currentTestData.attenuations && currentTestData.attenuations.length === freqLength) {
                            updatedSpectrumData.attenuations = [...currentTestData.attenuations];
                        } else {
                            // Calculate attenuations if possible
                            updatedSpectrumData.attenuations = Array(freqLength).fill(0);
                            for (let i = 0; i < freqLength; i++) {
                                if (updatedSpectrumData.baseline_levels[i] !== null && updatedSpectrumData.hat_levels[i] !== null) {
                                    updatedSpectrumData.attenuations[i] = updatedSpectrumData.baseline_levels[i] - updatedSpectrumData.hat_levels[i];
                                }
                            }
                        }
                    }
                    
                    // Ensure frequencies are properly formatted as numbers
                    updatedSpectrumData.frequencies = updatedSpectrumData.frequencies.map(f => 
                        typeof f === 'string' ? parseFloat(f) : f
                    );
                    
                    // Update the chart with our complete data
                    updateCharts(updatedSpectrumData);
                    
                    // Save a copy of the data for future use
                    currentTestData.frequencies = [...updatedSpectrumData.frequencies];
                    currentTestData.baseline_levels = [...updatedSpectrumData.baseline_levels];
                    currentTestData.hat_levels = [...updatedSpectrumData.hat_levels];
                    currentTestData.attenuations = [...updatedSpectrumData.attenuations];
                }
            }
            
            // Function to update a leaderboard table
            function updateLeaderboard(type, data) {
                const tableId = `${type}-leaderboard`;
                const table = document.getElementById(tableId);
                const tbody = table.querySelector('tbody');
                
                // Clear current entries
                tbody.innerHTML = '';
                
                if (data.length === 0) {
                    const row = document.createElement('tr');
                    row.innerHTML = '<td colspan="3" class="text-center">No entries yet</td>';
                    tbody.appendChild(row);
                    return;
                }
                
                // Add new entries without animation
                data.forEach((entry, index) => {
                    const row = document.createElement('tr');
                    
                    // Add medal class based on rank
                    if (index === 0) row.classList.add('first-place');
                    else if (index === 1) row.classList.add('second-place');
                    else if (index === 2) row.classList.add('third-place');
                    
                    row.innerHTML = `
                        <td class="rank">${index + 1}</td>
                        <td>${entry.name}</td>
                        <td class="attenuation">${entry.attenuation < 0 ? 
                            `<span class="negative-attenuation">${entry.attenuation.toFixed(2)}</span>` : 
                            entry.attenuation.toFixed(2)}</td>
                    `;
                    tbody.appendChild(row);
                });
            }
            
            // Function to update the spectrum charts
            function updateCharts(spectrumData) {
                // Make sure we have data to display
                if (!spectrumData.frequencies || !spectrumData.frequencies.length) {
                    console.warn('No spectrum data to display');
                    return;
                }
                
                // Format frequency labels (round to one decimal place)
                const formattedFreqs = spectrumData.frequencies.map(f => f.toFixed(1));
                
                // Log the frequency data for debugging
                console.log("Updating chart with frequencies:", formattedFreqs);
                
                // Check for all "0.0" values in the frequency labels - this indicates a potential problem
                const allZeros = formattedFreqs.every(f => f === "0.0");
                if (allZeros) {
                    console.error("All frequency labels are 0.0! This indicates missing frequency data.");
                    
                    // Try to recover using currentTestData frequencies if available
                    if (currentTestData && currentTestData.frequencies && currentTestData.frequencies.length > 0) {
                        console.log("Attempting to recover using saved frequency data");
                        const recoveredFreqs = currentTestData.frequencies.map(f => f.toFixed(1));
                        
                        // Replace with recovered frequencies
                        spectrumData.frequencies = [...currentTestData.frequencies];
                        formattedFreqs.splice(0, formattedFreqs.length, ...recoveredFreqs);
                    }
                }
                
                // Update power chart
                powerChart.data.labels = formattedFreqs;
                powerChart.data.datasets[0].data = spectrumData.baseline_levels;
                powerChart.data.datasets[1].data = spectrumData.hat_levels;
                powerChart.data.datasets[2].data = spectrumData.attenuations;
                
                // If we need to update the chart options (e.g., for new callbacks)
                updateChartCallbacks();
                
                // Update the chart
                powerChart.update();
                
                // Additional safety check after update - sometimes the x-axis ticks don't update properly
                setTimeout(() => {
                    const chartLabels = powerChart.data.labels;
                    const allSameValue = chartLabels.every((val, i, arr) => val === arr[0]);
                    
                    if (allSameValue && chartLabels.length > 1) {
                        console.warn(`Chart labels all have same value "${chartLabels[0]}" - attempting to fix`);
                        
                        // Try to recover from currentTestData
                        if (currentTestData && currentTestData.frequencies && 
                            currentTestData.frequencies.length === chartLabels.length) {
                            
                            console.log("Fixing chart labels with saved frequencies");
                            powerChart.data.labels = currentTestData.frequencies.map(f => f.toFixed(1));
                            powerChart.update();
                        }
                    }
                }, 100);
            }
            
            // Initial setup
            setupSSE();
            
            // Refresh the page once per hour to prevent memory leaks
            setTimeout(() => {
                window.location.reload();
            }, 3600000); // 1 hour
        });
    </script>
</body>
</html> 