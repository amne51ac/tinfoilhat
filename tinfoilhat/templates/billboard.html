<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tinfoil Hat Competition - Billboard</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/billboard.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap');
        
        body {
            background-color: #0a0a0a;
            color: #33ff33;
            font-family: 'VT323', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
        }
        
        /* CRT screen effect with scanlines */
        body::before {
            content: "";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0.1;
        }
        
        /* CRT flicker animation */
        body::after {
            content: "";
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 1001;
            pointer-events: none;
            animation: flicker 0.15s infinite alternate;
        }
        
        @keyframes flicker {
            0% { opacity: 0.025; }
            100% { opacity: 0.05; }
        }
        
        .billboard-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        
        .billboard-header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #33ff33;
            padding-bottom: 10px;
            position: relative;
        }
        
        .billboard-header::after {
            content: "";
            position: absolute;
            bottom: -2px;
            left: 30%;
            right: 30%;
            height: 2px;
            background: #33ff33;
            box-shadow: 0 0 5px #33ff33;
            animation: glow 2s infinite alternate;
        }
        
        @keyframes glow {
            from { opacity: 0.7; box-shadow: 0 0 3px #33ff33; }
            to { opacity: 1; box-shadow: 0 0 8px #33ff33; }
        }
        
        .billboard-header h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 2.2em;
            margin: 0;
            color: #33ff33;
            letter-spacing: 2px;
            text-shadow: 0 0 3px #33ff33;
            text-transform: uppercase;
        }
        
        .billboard-content {
            display: flex;
            flex: 1;
            gap: 20px;
        }
        
        .leaderboards-container {
            display: flex;
            flex: 1;
            gap: 20px;
        }
        
        .leaderboard {
            flex: 1;
            background-color: #111;
            border: 2px solid #33ff33;
            border-radius: 5px;
            padding: 15px;
            box-shadow: inset 0 0 10px rgba(51, 255, 51, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .leaderboard::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: #33ff33;
            box-shadow: 0 0 3px #33ff33;
        }
        
        .leaderboard h2 {
            text-align: center;
            margin-top: 0;
            color: #33ff33;
            border-bottom: 1px solid #33ff33;
            padding-bottom: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.4em;
            text-shadow: 0 0 2px #33ff33;
        }
        
        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .leaderboard-table th, .leaderboard-table td {
            padding: 10px;
            text-align: left;
            font-size: 1.5em;
            border-bottom: 1px solid rgba(51, 255, 51, 0.3);
        }
        
        .leaderboard-table th {
            border-bottom: 1px solid #33ff33;
            color: #fff;
            text-shadow: 0 0 2px #33ff33;
            font-size: 1.3em;
        }
        
        .leaderboard-table tbody tr:hover {
            background-color: rgba(51, 255, 51, 0.1);
        }
        
        .rank {
            font-weight: bold;
            width: 40px;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            font-size: 1em;
        }
        
        .attenuation {
            text-align: right;
            font-weight: bold;
            font-family: monospace;
            font-size: 1.3em;
        }
        
        .first-place {
            background-color: rgba(255, 215, 0, 0.2) !important;
            position: relative;
        }
        
        .first-place td {
            color: #ffdd00;
            text-shadow: 0 0 2px rgba(255, 215, 0, 0.7);
        }
        
        .second-place {
            background-color: rgba(192, 192, 192, 0.2) !important;
        }
        
        .second-place td {
            color: #cccccc;
        }
        
        .third-place {
            background-color: rgba(205, 127, 50, 0.2) !important;
        }
        
        .third-place td {
            color: #cc9966;
        }
        
        .negative-attenuation {
            color: #ff5555;
            text-shadow: 0 0 2px rgba(255, 0, 0, 0.7);
        }
        
        .testing-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #recent-test {
            flex: 1;
            background-color: #111;
            border: 2px solid #33ff33;
            border-radius: 5px;
            padding: 20px;
            box-shadow: inset 0 0 10px rgba(51, 255, 51, 0.3);
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        #recent-test::before {
            content: "LATEST TEST & SPECTRUM";
            position: absolute;
            top: 0;
            left: 0;
            background: #33ff33;
            color: #000;
            font-size: 0.8em;
            padding: 2px 10px;
            font-family: 'Press Start 2P', cursive;
            font-weight: bold;
        }
        
        .test-info {
            text-align: center;
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(51, 255, 51, 0.3);
        }

        #recent-test .contestant-name {
            font-size: 2.2em;
            font-weight: bold;
            margin-bottom: 5px;
            margin-top: 15px;
            text-shadow: 0 0 2px #33ff33;
        }
        
        #recent-test .hat-type {
            font-size: 1.8em;
            color: #bbffbb;
            margin-bottom: 10px;
        }
        
        #recent-test .attenuation {
            font-size: 2.8em;
            font-weight: bold;
            margin-bottom: 5px;
            font-family: 'VT323', monospace;
            text-shadow: 0 0 5px #33ff33;
        }
        
        #recent-test .test-date {
            font-size: 1.2em;
            color: #99ee99;
        }
        
        .chart-container {
            flex: 1;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border: 1px solid rgba(51, 255, 51, 0.5);
            padding: 20px 10px;
            min-height: 300px;
        }
        
        /* Styles for the measurement in progress indicator */
        .test-in-progress {
            margin-top: 5px;
            padding: 5px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            border: 1px solid #33ff33;
        }
        
        .measuring-indicator {
            color: #ffcc00;
            font-weight: bold;
            text-align: center;
            animation: blink 1s infinite alternate;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
        }
        
        @keyframes blink {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        /* Terminal effects */
        .terminal-effects {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            pointer-events: none;
        }
        
        /* Vignette effect */
        .terminal-effects::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 75%, rgba(0, 0, 0, 0.6) 100%);
            z-index: -1;
        }
        
        /* Terminal header elements */
        .terminal-header {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: 'VT323', monospace;
            color: #33ff33;
            display: flex;
            gap: 20px;
            opacity: 0.7;
        }
        
        /* Blinking cursor */
        .terminal-cursor {
            display: inline-block;
            background-color: #33ff33;
            width: 10px;
            height: 18px;
            margin-left: 2px;
            animation: cursor-blink 1s step-end infinite;
        }
        
        @keyframes cursor-blink {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        /* Terminal command line */
        .terminal-command {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-family: 'VT323', monospace;
            color: #33ff33;
            opacity: 0.7;
            display: flex;
            align-items: center;
        }
        
        .terminal-command::before {
            content: "root@tinfoilhat:~$ ";
            margin-right: 5px;
        }
        
        /* Labels on boxes for enhanced terminal aesthetic */
        .leaderboard::after {
            content: attr(data-label);
            position: absolute;
            top: -10px;
            left: 20px;
            background: #0a0a0a;
            padding: 0 10px;
            font-size: 0.8em;
            color: #33ff33;
            font-family: 'VT323', monospace;
        }

        /* Add crisp border style */
        .leaderboard, #recent-test, .spectrum-container {
            border: 2px solid #33ff33;
            box-shadow: inset 0 0 7px rgba(51, 255, 51, 0.2);
        }
    </style>
</head>
<body>
<div class="terminal-effects"></div>
<div class="terminal-header">
    <span>TINFOIL_HAT OS v2.0</span>
    <span id="terminal-time"></span>
</div>
<div class="terminal-command">
    ./run_billboard.sh <span class="terminal-cursor"></span>
</div>

<div class="billboard-container">
    <div class="billboard-header">
        <h1>TINFOIL HAT COMPETITION</h1>
    </div>
    <div class="billboard-content">
        <div class="leaderboards-container">
            <div class="leaderboard" data-label="CLASSIC.TXT">
                <h2>Classic Hats</h2>
                <table id="classic-leaderboard" class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Name</th>
                            <th>Attenuation (dB)</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% if leaderboard_classic %}
                            {% for entry in leaderboard_classic %}
                            <tr class="{% if loop.index == 1 %}first-place{% elif loop.index == 2 %}second-place{% elif loop.index == 3 %}third-place{% endif %}">
                                <td class="rank">{{ loop.index }}</td>
                                <td>{{ entry.name }}</td>
                                <td class="attenuation {% if entry.attenuation < 0 %}negative-attenuation{% endif %}">
                                    {{ "%.2f"|format(entry.attenuation) }}
                                </td>
                            </tr>
                            {% endfor %}
                        {% else %}
                            <tr>
                                <td colspan="3" class="text-center">No entries yet</td>
                            </tr>
                        {% endif %}
                    </tbody>
                </table>
            </div>
            <div class="leaderboard" data-label="HYBRID.TXT">
                <h2>Hybrid Hats</h2>
                <table id="hybrid-leaderboard" class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Name</th>
                            <th>Attenuation (dB)</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% if leaderboard_hybrid %}
                            {% for entry in leaderboard_hybrid %}
                            <tr class="{% if loop.index == 1 %}first-place{% elif loop.index == 2 %}second-place{% elif loop.index == 3 %}third-place{% endif %}">
                                <td class="rank">{{ loop.index }}</td>
                                <td>{{ entry.name }}</td>
                                <td class="attenuation {% if entry.attenuation < 0 %}negative-attenuation{% endif %}">
                                    {{ "%.2f"|format(entry.attenuation) }}
                                </td>
                            </tr>
                            {% endfor %}
                        {% else %}
                            <tr>
                                <td colspan="3" class="text-center">No entries yet</td>
                            </tr>
                        {% endif %}
                    </tbody>
                </table>
            </div>
        </div>
        <div class="testing-container">
            <div id="recent-test" data-label="SPECTRUM.DAT">
                <div class="test-info">
                    {% if recent_test and recent_test['max_id'] %}
                        <div class="contestant-name">{{ recent_test['name'] }}</div>
                        <div class="hat-type">{{ recent_test['hat_type']|capitalize }} Hat</div>
                        <div class="attenuation {% if recent_test['attenuation'] < 0 %}negative-attenuation{% endif %}">
                            {{ "%.2f"|format(recent_test['attenuation']) }} dB
                        </div>
                        <div class="test-date">{{ recent_test['date'] }}</div>
                    {% else %}
                        <div class="contestant-name">No Tests Yet</div>
                        <div class="hat-type">Waiting for data...</div>
                        <div class="attenuation">0.00 dB</div>
                        <div class="test-date">-</div>
                    {% endif %}
                </div>
                <div class="chart-container">
                    <canvas id="powerChart"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Terminal time display
        function updateTerminalTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', { 
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            document.getElementById('terminal-time').textContent = timeStr;
        }
        
        // Update time every second
        updateTerminalTime();
        setInterval(updateTerminalTime, 1000);

        // Initialize charts
        const powerCtx = document.getElementById('powerChart').getContext('2d');
        
        // Initialize with empty data initially
        const emptyData = {
            labels: [],
            datasets: []
        };
        
        // Power Chart (showing both baseline and hat readings, along with attenuation)
        const powerChart = new Chart(powerCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'Baseline (dBm)',
                        data: [],
                        borderColor: 'rgba(51, 255, 51, 0.8)',
                        backgroundColor: 'rgba(51, 255, 51, 0.1)',
                        tension: 0.2,
                        borderWidth: 2,
                        yAxisID: 'y'
                    }, 
                    {
                        label: 'With Hat (dBm)',
                        data: [],
                        borderColor: 'rgba(0, 200, 255, 0.8)',
                        backgroundColor: 'rgba(0, 200, 255, 0.1)',
                        tension: 0.2,
                        borderWidth: 2,
                        yAxisID: 'y'
                    },
                    {
                        label: 'Attenuation (dB)',
                        data: [],
                        borderColor: 'rgba(255, 204, 0, 0.8)',
                        backgroundColor: 'rgba(255, 204, 0, 0.1)',
                        tension: 0.2,
                        borderWidth: 2,
                        yAxisID: 'attenuation'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'RF SPECTRUM ANALYSIS',
                        color: '#33ff33',
                        font: {
                            size: 18,
                            family: "'Press Start 2P', cursive",
                            weight: 'bold'
                        },
                        padding: {
                            top: 10,
                            bottom: 20
                        }
                    },
                    legend: {
                        labels: {
                            color: '#33ff33',
                            font: {
                                family: "'VT323', monospace",
                                size: 18
                            },
                            boxWidth: 15,
                            padding: 15
                        }
                    },
                    tooltip: {
                        titleFont: {
                            family: "'VT323', monospace",
                            size: 18
                        },
                        bodyFont: {
                            family: "'VT323', monospace",
                            size: 17
                        },
                        backgroundColor: 'rgba(0, 0, 0, 0.85)',
                        borderColor: '#33ff33',
                        borderWidth: 1,
                        padding: 12,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.datasetIndex === 2) {
                                    // Attenuation dataset
                                    const value = context.parsed.y;
                                    const colorCode = value < 0 ? '🔴' : '🟢'; // Red for negative, green for positive
                                    return `${label}${value.toFixed(2)} dB ${colorCode}`;
                                } else {
                                    return `${label}${context.parsed.y.toFixed(2)} dBm`;
                                }
                            },
                            title: function(tooltipItems) {
                                const freq = tooltipItems[0].label;
                                if (freq) {
                                    return `${freq} MHz`;
                                }
                                return '';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'FREQUENCY (MHz)',
                            color: '#33ff33',
                            font: {
                                family: "'VT323', monospace",
                                size: 18
                            },
                            padding: {
                                top: 10
                            }
                        },
                        ticks: {
                            color: '#33ff33',
                            font: {
                                family: "'VT323', monospace",
                                size: 16
                            },
                            maxRotation: 45,
                            minRotation: 45,
                            callback: function(value, index, values) {
                                const freq = powerChart.data.labels[index];
                                if (!freq) return '';
                                
                                // Handle "0.0" values specially - they are likely a placeholder
                                if (freq === "0.0" || freq === 0.0) {
                                    // Try to use the last known good frequencies if available
                                    if (currentTestData && currentTestData.frequencies && currentTestData.frequencies.length > index) {
                                        const validFreq = currentTestData.frequencies[index].toFixed(1);
                                        console.log(`Replaced "0.0" with ${validFreq} from saved data at index ${index}`);
                                        return validFreq;
                                    }
                                }
                                
                                return freq;
                            }
                        },
                        grid: {
                            color: 'rgba(51, 255, 51, 0.08)',
                            tickBorderDash: [4, 4]
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'SIGNAL LEVEL (dBm)',
                            color: '#33ff33',
                            font: {
                                family: "'VT323', monospace",
                                size: 18
                            },
                            padding: {
                                bottom: 10
                            }
                        },
                        ticks: {
                            color: '#33ff33',
                            font: {
                                family: "'VT323', monospace",
                                size: 16
                            }
                        },
                        grid: {
                            color: 'rgba(51, 255, 51, 0.08)',
                            tickBorderDash: [4, 4]
                        },
                        min: -100,
                        max: -60
                    },
                    attenuation: {
                        position: 'right',
                        title: {
                            display: true,
                            text: 'ATTENUATION (dB)',
                            color: '#ffcc00',
                            font: {
                                family: "'VT323', monospace",
                                size: 18
                            },
                            padding: {
                                bottom: 10
                            }
                        },
                        ticks: {
                            color: '#ffcc00',
                            font: {
                                family: "'VT323', monospace",
                                size: 16
                            }
                        },
                        grid: {
                            drawOnChartArea: false,
                            color: 'rgba(255, 204, 0, 0.08)',
                            tickBorderDash: [4, 4]
                        },
                        min: -10,
                        max: 10
                    }
                }
            }
        });
        
        // Call updateChartCallbacks to apply our callback functions with window.frequencyLabels
        updateChartCallbacks();
        
        // Initialize with global frequency labels from the server if available
        window.frequencyLabels = {};
        {% if frequency_labels %}
            window.frequencyLabels = {{ frequency_labels|tojson }};
        {% endif %}
        
        // Initialize charts with existing data if available
        {% if spectrum_data and spectrum_data.frequencies %}
            // Ensure frequencies are properly formatted as numbers
            const frequencies = {{ spectrum_data.frequencies|tojson }};
            const frequencyLabels = frequencies.map(f => {
                // Convert to number if it's a string
                const fNum = typeof f === 'string' ? parseFloat(f) : f;
                return fNum.toFixed(1);
            });
            const baselineLevels = {{ spectrum_data.baseline_levels|tojson }};
            const hatLevels = {{ spectrum_data.hat_levels|tojson }};
            const attenuations = {{ spectrum_data.attenuations|tojson }};
            
            console.log("Initial frequencies:", frequencyLabels);
            
            // Update power chart
            powerChart.data.labels = frequencyLabels;
            powerChart.data.datasets[0].data = baselineLevels;
            powerChart.data.datasets[1].data = hatLevels;
            powerChart.data.datasets[2].data = attenuations;
            powerChart.update();
        {% endif %}
        
        // Connect to SSE endpoint for real-time updates
        let lastId = {{ recent_test['max_id'] if recent_test and recent_test['max_id'] else 0 }};
        let usePolling = false;
        let eventSource;
        let frequencyEventSource;
        
        // Create objects to store the current test data as it's being measured
        let currentTestData = {
            frequencies: [],
            baseline_levels: [],
            hat_levels: [],
            attenuations: [],
            measurement_type: null,
            contestant_id: null,
            contestant_name: null,
            hat_type: null
        };
        
        function setupSSE() {
            try {
                // Main leaderboard updates
                eventSource = new EventSource(`/billboard-updates?last_id=${lastId}`);
                
                eventSource.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    updateBillboard(data);
                    lastId = data.last_id;
                };
                
                eventSource.onerror = function(e) {
                    console.log('SSE connection error, falling back to polling...');
                    eventSource.close();
                    usePolling = true;
                    startPolling();
                };
                
                // Real-time frequency measurement updates
                frequencyEventSource = new EventSource('/frequency-stream');
                
                frequencyEventSource.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    handleFrequencyUpdate(data);
                };
                
                frequencyEventSource.onerror = function(e) {
                    console.log('Frequency stream connection error');
                    frequencyEventSource.close();
                    // Try to reconnect after a short delay
                    setTimeout(() => {
                        frequencyEventSource = new EventSource('/frequency-stream');
                    }, 3000);
                };
            } catch (e) {
                console.log('Error setting up SSE, falling back to polling:', e);
                usePolling = true;
                startPolling();
            }
        }
        
        // Event handlers for data streaming
        function handleFrequencyUpdate(data) {
            // Check if this is a measurement update or a test completion event
            if (data.event_type === 'test_complete') {
                // This is a final test result
                console.log('Test complete event received:', data);
                
                // Important: Do not reset or modify current test data or chart
                // The billboard update will handle the leaderboard/recent test updates
                // but we'll preserve the current chart data as-is since it likely has better frequency info
                
                // Mark the current state as completed but don't change the data
                console.log("Test complete - preserving current chart data");
                
                // Update the UI to remove the "in progress" indicator without changing chart data
                const testInProgress = document.querySelector('.test-in-progress');
                if (testInProgress) {
                    testInProgress.remove();
                }
                
                return;
            }
            
            // This is a single frequency measurement update
            console.log('Frequency update:', data);
            
            // Store the contestant information if available
            if (data.contestant_id && !currentTestData.contestant_id) {
                currentTestData.contestant_id = data.contestant_id;
            }
            
            // Store contestant name and hat type if available
            if (data.contestant_name) {
                currentTestData.contestant_name = data.contestant_name;
            }
            
            if (data.hat_type) {
                currentTestData.hat_type = data.hat_type;
            }
            
            // Update measurement type
            currentTestData.measurement_type = data.measurement_type;
            
            // Process based on measurement type
            if (data.measurement_type === 'baseline') {
                // Store baseline measurement
                const freqIndex = currentTestData.frequencies.indexOf(data.frequency_mhz);
                if (freqIndex === -1) {
                    // New frequency
                    currentTestData.frequencies.push(data.frequency_mhz);
                    currentTestData.baseline_levels.push(data.power);
                    
                    // Sort the arrays by frequency
                    const sortIndices = [...currentTestData.frequencies.keys()]
                        .sort((a, b) => currentTestData.frequencies[a] - currentTestData.frequencies[b]);
                    
                    currentTestData.frequencies = sortIndices.map(i => currentTestData.frequencies[i]);
                    currentTestData.baseline_levels = sortIndices.map(i => currentTestData.baseline_levels[i]);
                    
                    // Add placeholder null values for hat and attenuation
                    if (currentTestData.hat_levels.length < currentTestData.frequencies.length) {
                        currentTestData.hat_levels.push(null);
                        currentTestData.attenuations.push(null);
                    }
                } else {
                    // Update existing frequency
                    currentTestData.baseline_levels[freqIndex] = data.power;
                }
            } else if (data.measurement_type === 'hat') {
                // Store hat measurement and attenuation if available
                const freqIndex = currentTestData.frequencies.indexOf(data.frequency_mhz);
                if (freqIndex === -1) {
                    // New frequency
                    currentTestData.frequencies.push(data.frequency_mhz);
                    currentTestData.hat_levels.push(data.power);
                    currentTestData.attenuations.push(data.attenuation || null);
                    
                    // Add placeholder null value for baseline if needed
                    if (currentTestData.baseline_levels.length < currentTestData.frequencies.length) {
                        currentTestData.baseline_levels.push(null);
                    }
                    
                    // Sort the arrays by frequency
                    const sortIndices = [...currentTestData.frequencies.keys()]
                        .sort((a, b) => currentTestData.frequencies[a] - currentTestData.frequencies[b]);
                    
                    currentTestData.frequencies = sortIndices.map(i => currentTestData.frequencies[i]);
                    currentTestData.baseline_levels = sortIndices.map(i => currentTestData.baseline_levels[i]);
                    currentTestData.hat_levels = sortIndices.map(i => currentTestData.hat_levels[i]);
                    currentTestData.attenuations = sortIndices.map(i => currentTestData.attenuations[i]);
                } else {
                    // Update existing frequency
                    currentTestData.hat_levels[freqIndex] = data.power;
                    currentTestData.attenuations[freqIndex] = data.attenuation || null;
                }
            }
            
            // For debugging, log the state of currentTestData
            console.log("Current test data updated, frequencies:", currentTestData.frequencies.length);
            
            // Update the recent test information with current test data
            updateRecentTestWithCurrentData();
            
            // Update the charts with the real-time data
            updateChartsWithLiveData();
        }
        
        // Function to update the recent test display
        function updateRecentTest(testData) {
            const recentTest = document.getElementById('recent-test');
            const testInfo = recentTest.querySelector('.test-info');
            
            console.log("Updating recent test display with:", testData);
            
            // No animation class, just update content
            testInfo.innerHTML = `
                <div class="contestant-name">${testData.name}</div>
                <div class="hat-type">${testData.hat_type.charAt(0).toUpperCase() + testData.hat_type.slice(1)} Hat</div>
                <div class="attenuation ${testData.attenuation < 0 ? 'negative-attenuation' : ''}">
                    ${testData.attenuation.toFixed(2)} dB
                </div>
                <div class="test-date">${testData.date}</div>
            `;
            
            // IMPORTANT: We DO NOT update the chart data here
            // The spectrum graph will continue to display the streaming data with proper frequency labels
        }
        
        // Function to update the recent test display with current test data
        function updateRecentTestWithCurrentData() {
            const recentTest = document.getElementById('recent-test');
            const testInfo = recentTest.querySelector('.test-info');
            
            // Set contestant name (use "Baseline" if in baseline measurement mode)
            let displayName = "Unknown";
            if (currentTestData.measurement_type === 'baseline') {
                displayName = "Baseline";
            } else if (currentTestData.contestant_name) {
                displayName = currentTestData.contestant_name;
            }
            
            // Set hat type
            let hatTypeDisplay = "Measuring...";
            if (currentTestData.hat_type) {
                hatTypeDisplay = currentTestData.hat_type.charAt(0).toUpperCase() + 
                                currentTestData.hat_type.slice(1) + " Hat";
            } else if (currentTestData.measurement_type === 'baseline') {
                hatTypeDisplay = "Baseline Measurement";
            }
            
            // Calculate average attenuation from valid values
            let avgAttenuation = 0;
            let validAttenuations = currentTestData.attenuations.filter(a => a !== null);
            if (validAttenuations.length > 0) {
                avgAttenuation = validAttenuations.reduce((sum, val) => sum + val, 0) / validAttenuations.length;
            }
            
            // Create HTML for recent test
            testInfo.innerHTML = `
                <div class="contestant-name">${displayName}</div>
                <div class="hat-type">${hatTypeDisplay}</div>
                <div class="attenuation ${avgAttenuation < 0 ? 'negative-attenuation' : ''}">
                    ${avgAttenuation.toFixed(2)} dB
                </div>
                <div class="test-date">In Progress</div>
            `;
            
            // Add the "measurement in progress" indicator if it doesn't exist
            if (!recentTest.querySelector('.test-in-progress')) {
                const testInProgress = document.createElement('div');
                testInProgress.className = 'test-in-progress';
                testInProgress.innerHTML = '<div class="measuring-indicator">MEASUREMENT IN PROGRESS</div>';
                testInfo.appendChild(testInProgress);
            }
        }
        
        // Update charts with the current test data
        function updateChartsWithLiveData() {
            // Don't update if no data available
            if (currentTestData.frequencies.length === 0) {
                return;
            }
            
            // Update power chart with available data
            const formattedLabels = currentTestData.frequencies.map(f => f.toFixed(1));
            powerChart.data.labels = formattedLabels;
            powerChart.data.datasets[0].data = currentTestData.baseline_levels;
            powerChart.data.datasets[1].data = currentTestData.hat_levels;
            powerChart.data.datasets[2].data = currentTestData.attenuations;
            powerChart.update();
        }
        
        // Polling fallback
        function startPolling() {
            if (!usePolling) return;
            
            // Poll for updates every 5 seconds
            const pollInterval = 5000;
            
            function pollForUpdates() {
                fetch(`/billboard-updates?last_id=${lastId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.new_test) {
                            updateBillboard(data);
                            lastId = data.last_id;
                        }
                    })
                    .catch(error => console.error('Polling error:', error))
                    .finally(() => {
                        if (usePolling) {
                            setTimeout(pollForUpdates, pollInterval);
                        }
                    });
            }
            
            pollForUpdates();
        }
        
        // Function to update a leaderboard table
        function updateLeaderboard(type, data) {
            const tableId = `${type}-leaderboard`;
            const table = document.getElementById(tableId);
            const tbody = table.querySelector('tbody');
            
            // Clear current entries
            tbody.innerHTML = '';
            
            if (data.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = '<td colspan="3" class="text-center">No entries yet</td>';
                tbody.appendChild(row);
                return;
            }
            
            // Add new entries without animation
            data.forEach((entry, index) => {
                const row = document.createElement('tr');
                
                // Add medal class based on rank
                if (index === 0) row.classList.add('first-place');
                else if (index === 1) row.classList.add('second-place');
                else if (index === 2) row.classList.add('third-place');
                
                row.innerHTML = `
                    <td class="rank">${index + 1}</td>
                    <td>${entry.name}</td>
                    <td class="attenuation">${entry.attenuation < 0 ? 
                        `<span class="negative-attenuation">${entry.attenuation.toFixed(2)}</span>` : 
                        entry.attenuation.toFixed(2)}</td>
                `;
                tbody.appendChild(row);
            });
        }
        
        // Function to update the spectrum charts
        function updateCharts(spectrumData) {
            // Make sure we have data to display
            if (!spectrumData.frequencies || !spectrumData.frequencies.length) {
                console.warn('No spectrum data to display');
                return;
            }
            
            // Format frequency labels (round to one decimal place)
            const formattedFreqs = spectrumData.frequencies.map(f => f.toFixed(1));
            
            // Log the frequency data for debugging
            console.log("Updating chart with frequencies:", formattedFreqs);
            
            // Check for all "0.0" values in the frequency labels - this indicates a potential problem
            const allZeros = formattedFreqs.every(f => f === "0.0");
            if (allZeros) {
                console.error("All frequency labels are 0.0! This indicates missing frequency data.");
                
                // Try to recover using currentTestData frequencies if available
                if (currentTestData && currentTestData.frequencies && currentTestData.frequencies.length > 0) {
                    console.log("Attempting to recover using saved frequency data");
                    const recoveredFreqs = currentTestData.frequencies.map(f => f.toFixed(1));
                    
                    // Replace with recovered frequencies
                    spectrumData.frequencies = [...currentTestData.frequencies];
                    formattedFreqs.splice(0, formattedFreqs.length, ...recoveredFreqs);
                }
            }
            
            // Update power chart
            powerChart.data.labels = formattedFreqs;
            powerChart.data.datasets[0].data = spectrumData.baseline_levels;
            powerChart.data.datasets[1].data = spectrumData.hat_levels;
            powerChart.data.datasets[2].data = spectrumData.attenuations;
            
            // If we need to update the chart options (e.g., for new callbacks)
            updateChartCallbacks();
            
            // Update the chart
            powerChart.update();
            
            // Additional safety check after update - sometimes the x-axis ticks don't update properly
            setTimeout(() => {
                const chartLabels = powerChart.data.labels;
                const allSameValue = chartLabels.every((val, i, arr) => val === arr[0]);
                
                if (allSameValue && chartLabels.length > 1) {
                    console.warn(`Chart labels all have same value "${chartLabels[0]}" - attempting to fix`);
                    
                    // Try to recover from currentTestData
                    if (currentTestData && currentTestData.frequencies && 
                        currentTestData.frequencies.length === chartLabels.length) {
                        
                        console.log("Fixing chart labels with saved frequencies");
                        powerChart.data.labels = currentTestData.frequencies.map(f => f.toFixed(1));
                        powerChart.update();
                    }
                }
            }, 100);
        }
        
        // Function to update chart callbacks to use the window.frequencyLabels
        function updateChartCallbacks() {
            // Update tooltip callback to use window.frequencyLabels
            powerChart.options.plugins.tooltip.callbacks.title = function(tooltipItems) {
                const freq = tooltipItems[0].label;
                if (freq) {
                    const freqNum = parseFloat(freq);
                    // Check if we have window.frequencyLabels and use them
                    if (window.frequencyLabels && Object.keys(window.frequencyLabels).length > 0) {
                        for (const [freqMhz, labelData] of Object.entries(window.frequencyLabels)) {
                            if (Math.abs(freqNum - parseFloat(freqMhz)) < 0.1) {
                                if (labelData[1]) {
                                    return `${freq} MHz (${labelData[0]}) - ${labelData[1]}`;
                                } else {
                                    return `${freq} MHz (${labelData[0]})`;
                                }
                            }
                        }
                    }
                    // If no matching label found or no labels available, just show frequency
                    return `${freq} MHz`;
                }
                return '';
            };
            
            // Update x-axis tick callback to use window.frequencyLabels
            powerChart.options.scales.x.ticks.callback = function(value, index, values) {
                const freq = powerChart.data.labels[index];
                if (!freq) return '';
                
                // Make sure freq is a string
                const freqStr = freq.toString();
                
                // Try to get a label for this frequency
                const freqNum = parseFloat(freqStr);
                if (window.frequencyLabels && Object.keys(window.frequencyLabels).length > 0) {
                    for (const [freqMhz, labelData] of Object.entries(window.frequencyLabels)) {
                        if (Math.abs(freqNum - parseFloat(freqMhz)) < 0.1) {
                            return `${freqStr} (${labelData[0]})`;
                        }
                    }
                }
                
                // If no label found, use a common band name based on frequency if possible
                if (freqNum >= 88 && freqNum <= 108) return `${freqStr} (FM)`;
                if (freqNum >= 470 && freqNum <= 806) return `${freqStr} (UHF)`;
                if (freqNum >= 2400 && freqNum <= 2500) return `${freqStr} (WiFi)`;
                if (freqNum >= 5100 && freqNum <= 5800) return `${freqStr} (5G WiFi)`;
                
                // Default case, just return the frequency
                return freqStr;
            };
        }
        
        // Common function to update the billboard with new data
        function updateBillboard(data) {
            // Log the entire data object for debugging
            console.log("============== BILLBOARD UPDATE =============");
            console.log("Received billboard update with data:", data);
            console.log("============================================");
            
            // Update the recent test display
            if (data.new_test) {
                updateRecentTest(data.new_test);
                
                // Remove the "Measurement in Progress" indicator if it exists
                const testInProgress = document.querySelector('.test-in-progress');
                if (testInProgress) {
                    testInProgress.remove();
                }
                
                // IMPORTANT: Do NOT reset currentTestData completely anymore
                // Instead, we'll keep the frequency data and only reset measurement-specific fields
                // This ensures we'll have frequencies available even if the complete test data doesn't include them
                currentTestData.measurement_type = null;
                currentTestData.contestant_id = null;
                currentTestData.contestant_name = null;
                currentTestData.hat_type = null;
                
                // We keep frequencies[], baseline_levels[], hat_levels[], and attenuations[] intact
            }
            
            // Update leaderboards
            if (data.leaderboard_classic) {
                updateLeaderboard('classic', data.leaderboard_classic);
            }
            
            if (data.leaderboard_hybrid) {
                updateLeaderboard('hybrid', data.leaderboard_hybrid);
            }
            
            // Store frequency labels if available for chart tooltips and axis labels
            if (data.frequency_labels) {
                console.log("Received frequency labels:", data.frequency_labels);
                window.frequencyLabels = data.frequency_labels;
            }
            
            // Update charts with spectrum data ONLY if there's meaningful data
            if (data.spectrum_data && Object.keys(data.spectrum_data).length > 0) {
                console.log("Received spectrum data:", data.spectrum_data);
                
                // Skip updating the chart entirely if this is a test completion AND we have no or bad frequency data
                // This ensures we keep displaying the streaming data which has correct frequencies
                if (data.new_test) {
                    // Check if data has missing/bad frequencies
                    const hasBadFrequencies = !data.spectrum_data.frequencies || 
                                              data.spectrum_data.frequencies.length === 0 || 
                                              data.spectrum_data.frequencies.every(f => f === 0 || f === '0' || f === '0.0');
                    
                    if (hasBadFrequencies) {
                        console.warn("Test completion data has missing or zero frequencies - keeping current chart display");
                        return; // Don't update the chart at all, keep showing what we already have
                    }
                }
                
                // Create a copy of spectrum data to work with
                const updatedSpectrumData = {...data.spectrum_data};
                
                // Check if frequencies are missing or empty in the incoming data
                if (!updatedSpectrumData.frequencies || updatedSpectrumData.frequencies.length === 0) {
                    console.warn("Missing frequencies in spectrum data - using saved frequencies from current test data");
                    
                    // Use frequencies from currentTestData if available
                    if (currentTestData.frequencies && currentTestData.frequencies.length > 0) {
                        updatedSpectrumData.frequencies = [...currentTestData.frequencies];
                        console.log("Using saved frequencies:", updatedSpectrumData.frequencies);
                    } else {
                        console.error("No frequency data available - cannot update chart");
                        return;
                    }
                }
                
                // Ensure other required arrays exist and have correct length
                const freqLength = updatedSpectrumData.frequencies.length;
                
                // Check baseline levels
                if (!updatedSpectrumData.baseline_levels || updatedSpectrumData.baseline_levels.length !== freqLength) {
                    if (currentTestData.baseline_levels && currentTestData.baseline_levels.length === freqLength) {
                        updatedSpectrumData.baseline_levels = [...currentTestData.baseline_levels];
                    } else {
                        updatedSpectrumData.baseline_levels = Array(freqLength).fill(-85); // Default value
                    }
                }
                
                // Check hat levels
                if (!updatedSpectrumData.hat_levels || updatedSpectrumData.hat_levels.length !== freqLength) {
                    if (currentTestData.hat_levels && currentTestData.hat_levels.length === freqLength) {
                        updatedSpectrumData.hat_levels = [...currentTestData.hat_levels];
                    } else {
                        updatedSpectrumData.hat_levels = Array(freqLength).fill(-85); // Default value
                    }
                }
                
                // Check attenuations
                if (!updatedSpectrumData.attenuations || updatedSpectrumData.attenuations.length !== freqLength) {
                    if (currentTestData.attenuations && currentTestData.attenuations.length === freqLength) {
                        updatedSpectrumData.attenuations = [...currentTestData.attenuations];
                    } else {
                        // Calculate attenuations if possible
                        updatedSpectrumData.attenuations = Array(freqLength).fill(0);
                        for (let i = 0; i < freqLength; i++) {
                            if (updatedSpectrumData.baseline_levels[i] !== null && updatedSpectrumData.hat_levels[i] !== null) {
                                updatedSpectrumData.attenuations[i] = updatedSpectrumData.baseline_levels[i] - updatedSpectrumData.hat_levels[i];
                            }
                        }
                    }
                }
                
                // Ensure frequencies are properly formatted as numbers
                updatedSpectrumData.frequencies = updatedSpectrumData.frequencies.map(f => 
                    typeof f === 'string' ? parseFloat(f) : f
                );
                
                // Update the chart with our complete data
                updateCharts(updatedSpectrumData);
                
                // Save a copy of the data for future use
                currentTestData.frequencies = [...updatedSpectrumData.frequencies];
                currentTestData.baseline_levels = [...updatedSpectrumData.baseline_levels];
                currentTestData.hat_levels = [...updatedSpectrumData.hat_levels];
                currentTestData.attenuations = [...updatedSpectrumData.attenuations];
            }
        }
        
        // Initial setup
        setupSSE();
        
        // Refresh the page once per hour to prevent memory leaks
        setTimeout(() => {
            window.location.reload();
        }, 3600000); // 1 hour
    });
</script>
</body>
</html> 